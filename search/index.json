[{"content":"Windows-查找大文件 使用命令：\n1 forfiles /p E:\\ /s /m *.* /c \u0026#34;cmd /c if @fsize geq 104857600 (echo @path @fsize)\u0026#34; \u0026gt; E:\\big_files.txt Excel数据大小易于阅读公式\n1 2 3 4 5 6 7 8 9 10 11 12 13 =IF( A1\u0026gt;=1024^3, ROUND(A1/1024^3, 2)\u0026amp;\u0026#34; GB\u0026#34;, IF( A1\u0026gt;=1024^2, ROUND(A1/1024^2, 2)\u0026amp;\u0026#34; MB\u0026#34;, IF( A1\u0026gt;=1024, ROUND(A1/1024, 2)\u0026amp;\u0026#34; KB\u0026#34;, A1\u0026amp;\u0026#34; B\u0026#34; ) ) ) 将结果导入Excel进行排序和分析\n","date":"2025-09-13T14:33:55+08:00","permalink":"https://blog-g.leecq.cn/p/windows-%E6%9F%A5%E6%89%BE%E5%A4%A7%E6%96%87%E4%BB%B6/","title":"Windows-查找大文件"},{"content":"UV：让Python开发飞起来的神器！✨ 🔥 为什么每个Python开发者都在疯狂安利UV？ 💨 速度快到你怀疑人生！\n比pip快10-100倍！安装依赖从泡咖啡时间缩短到眨眼功夫 实测UV约比pip快至少10倍以上，复杂项目提升更明显⚡️ 告别漫长等待，开发效率瞬间起飞！ 一个工具搞定所有事情！ 再也不用在pip、pipenv、poetry之间纠结了： 一个UV = 整个工具链！ 电脑内存和心智负担都减轻了～\n✅ 包管理 ✅ 虚拟环境 ✅ 项目初始化 ✅ Python版本管理 ✅ 依赖锁定 🛡️ 依赖冲突？不存在的！\n智能依赖解析，自动避免版本冲突 锁文件确保团队环境100%一致 再也不会出现\u0026quot;在我电脑上能跑\u0026quot;的尴尬 🚀 现代化体验，告别石器时代\n零配置开箱即用 命令简洁易记 错误提示超级友好 跨平台无缝使用 📖 上手指南 Step 1️⃣：一键安装 macOS/Linux 用户\ncurl -LsSf https://astral.sh/uv/install.sh | sh\nWindows 用户\npowershell -c \u0026quot;irm https://astral.sh/uv/install.ps1 | iex\u0026quot;\n也可以用包管理器\nbrew install uv # macOS\nscoop install uv # Windows\nStep 2️⃣：创建项目（3秒搞定！） 1 2 3 4 5 6 7 8 # 初始化新项目 uv init my-awesome-project cd my-awesome-project # 自动生成标准项目结构 📁 # ├── README.md # ├── pyproject.toml # └── src/my_awesome_project/ Step 3️⃣：管理依赖（比点外卖还简单！） 1 2 3 4 5 6 7 8 9 10 11 # 添加常用包 uv add requests pandas numpy matplotlib # 添加开发工具 uv add pytest black ruff --dev # 一键安装所有依赖 uv sync # 运行代码（自动激活环境） uv run python main.py 🎪 日常使用技巧大公开 🛠️ 项目管理篇 快速添加依赖\n1 2 3 4 5 6 7 8 # 基础用法 uv add requests # 添加最新版本 uv add \u0026#34;django\u0026gt;=4.0\u0026#34; # 指定版本范围 uv add pytest --dev # 开发依赖 # 高级用法 uv add jupyter --group notebook # 分组管理 uv add mysql-connector-python --optional database # 可选依赖 环境同步\n1 2 3 4 5 6 7 8 # 完整同步（包括开发依赖） uv sync # 只要生产依赖 uv sync --no-dev # 同步特定组 uv sync --group docs --group test 🐍 Python版本管理篇 1 2 3 4 5 6 7 8 9 10 11 12 # 查看可用版本 uv python list # 安装多个Python版本 uv python install 3.10 3.11 3.12 # 为项目指定Python版本 uv python pin 3.11 # 用不同版本测试 uv run --python 3.10 pytest uv run --python 3.12 pytest 🔧 工具安装篇 1 2 3 4 5 6 7 8 9 10 # 安装全局工具 uv tool install black ruff jupyter # 直接运行工具（无需安装） uv tool run black . uv tool run ruff check # 管理已安装工具 uv tool list uv tool upgrade black 🎯 实战场景 🆕 新项目快速启动 1 2 3 4 5 6 7 8 9 10 11 12 # 1. 创建项目 uv init web-scraper cd web-scraper # 2. 添加依赖 uv add requests beautifulsoup4 pandas # 3. 添加开发工具 uv add pytest black ruff --dev # 4. 开始编码 uv run python src/web_scraper/main.py 👥 团队协作 1 2 3 4 5 6 7 8 9 # 队友拉取代码后一键安装 git clone project-repo cd project-repo uv sync # 根据uv.lock完全复现环境 # 更新依赖后通知队友 uv add new-package git add uv.lock pyproject.toml git commit -m \u0026#34;Add new-package dependency\u0026#34; 🚢 部署准备 1 2 3 4 5 6 7 8 9 # 生成requirements.txt给Docker用 uv export --format requirements-txt \u0026gt; requirements.txt # 构建发布包 uv build # 发布到PyPI uv publish 🆘 遇到问题？秒速解决！ 常见问题速查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 🔧 清理缓存 uv cache clean # 🔄 重建环境 rm -rf .venv \u0026amp;\u0026amp; uv sync # 🔍 查看依赖树 uv tree # 🐛 详细日志调试 uv sync --verbose # ✅ 检查配置 uv --version 救命技巧 1 2 3 4 5 6 7 8 # 依赖冲突解决 uv lock --resolution lowest-direct # 验证环境一致性 uv lock --check # 强制重新解析 uv lock --upgrade ","date":"2025-09-04T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/uv%E8%AE%A9python%E5%BC%80%E5%8F%91%E9%A3%9E%E8%B5%B7%E6%9D%A5%E7%9A%84%E7%A5%9E%E5%99%A8/","title":"UV：让Python开发飞起来的神器"},{"content":" 使用Python创建的一个具有固定项目的倒计时工具。\n固定项目有： 第一列：建一、建二、盾兵、矛兵、射手、科技、捐献, 仓库 第二列：行军一、行军二、行军三、行军四、行军五 浮窗1：这些项目显示在浮窗中，大小需要保证99时59分59秒的长度能够正确显示，浮窗透明，倒计时未到期的项目行显示绿色；剩余2分钟内显示黄色；到期后项目行显示红色并开始正计时，浮动在所有窗口的前面； 浮窗2： 一个30*30的正方形半透明浮窗，所有队列大于2min时显示绿等，存在小与2分钟的队列时黄灯，存在超期的项目显示红灯； 将配置保存在零时目录中，启动后先从零时目录加载之前的配置,在每次点击应用后保存，过程数据无需保存； 程序通过托盘运行在后台，通过托盘图标可以打开配置剩余时间的界面，也可以双击浮窗打开设计界面； 设置时间的界面每个项目后面分别允许输入时，分，秒，并通过应用按钮应用并更新该项目的倒计时，更新后的配置时间显示在对应的输入框中。 使用全局快捷键 Ctrl+Shift+Q 控制在2个浮窗和隐藏3个状态中切换，允许在设置中更改快捷键，整合在倒计时配置界面； 使用全局快捷键 Ctrl+Shift+S 快速打开设置窗口，允许在设置中更改快捷键，整合在倒计时配置界面； 在任务到期后发出一个通知，并在设置界面中添加一个选项，是否启用通知; 在控制台上打印关键关键位置的日志，便于排查和理解程序运行状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 \u0026#34;\u0026#34;\u0026#34; 使用Python创建一个具有固定项目的倒计时工具。 1. 固定项目有： 第一列：建一、建二、盾兵、矛兵、射手、科技、捐献, 仓库 第二列：行军一、行军二、行军三、行军四、行军五 2.1 浮窗1：这些项目显示在浮窗中，大小需要保证99时59分59秒的长度能够正确显示，浮窗透明，倒计时未到期的项目行显示绿色；剩余2分钟内显示黄色；到期后项目行显示红色并开始正计时，浮动在所有窗口的前面； 2.2 浮窗2： 一个30*30的正方形半透明浮窗，所有队列大于2min时显示绿等，存在小与2分钟的队列时黄灯，存在超期的项目显示红灯； 3. 将配置保存在零时目录中，启动后先从零时目录加载之前的配置,在每次点击应用后保存，过程数据无需保存； 4. 程序通过托盘运行在后台，通过托盘图标可以打开配置剩余时间的界面，也可以双击浮窗打开设计界面； 5. 设置时间的界面每个项目后面分别允许输入时，分，秒，并通过应用按钮应用并更新该项目的倒计时，更新后的配置时间显示在对应的输入框中。 6. 使用全局快捷键 Ctrl+Shift+Q 控制在2个浮窗和隐藏3个状态中切换，允许在设置中更改快捷键，整合在倒计时配置界面； 7. 使用全局快捷键 Ctrl+Shift+S 快速打开设置窗口，允许在设置中更改快捷键，整合在倒计时配置界面； 8. 在任务到期后发出一个通知，并在设置界面中添加一个选项，是否启用通知; 9. 在控制台上打印关键关键位置的日志，便于排查和理解程序运行状态。 pip install pystray pillow \u0026#34;\u0026#34;\u0026#34; import tkinter as tk from tkinter import ttk, messagebox import pystray from pystray import MenuItem as item from PIL import Image, ImageDraw import datetime import time import threading import re import tempfile import os import json import logging from plyer import notification import keyboard # 配置日志输出 logging.basicConfig( level=logging.INFO, format=\u0026#39;%(asctime)s - %(levelname)s - %(message)s\u0026#39;, handlers=[ logging.StreamHandler() ] ) class ProjectCountdownApp: def __init__(self): logging.info(\u0026#34;启动项目倒计时工具\u0026#34;) # 固定项目列表 self.projects = { \u0026#34;建一\u0026#34;: None, \u0026#34;建二\u0026#34;: None, \u0026#34;盾兵\u0026#34;: None, \u0026#34;矛兵\u0026#34;: None, \u0026#34;射手\u0026#34;: None, \u0026#34;科技\u0026#34;: None, \u0026#34;捐献\u0026#34;: None, \u0026#34;仓库\u0026#34;: None, \u0026#34;行军一\u0026#34;: None, \u0026#34;行军二\u0026#34;: None, \u0026#34;行军三\u0026#34;: None, \u0026#34;行军四\u0026#34;: None, \u0026#34;行军五\u0026#34;: None } # 存储设置的原始时间（小时、分钟、秒） self.original_times = {project: (0, 0, 0) for project in self.projects.keys()} # 存储已到期项目的正计时开始时间 self.elapsed_start = {project: None for project in self.projects.keys()} # 记录项目是否已发送过通知 self.notification_sent = {project: False for project in self.projects.keys()} # 快捷键配置 self.hotkeys = { \u0026#39;toggle_windows\u0026#39;: \u0026#39;ctrl+shift+q\u0026#39;, # 切换浮窗状态 \u0026#39;open_settings\u0026#39;: \u0026#39;ctrl+shift+s\u0026#39; # 打开设置窗口 } # 存储快捷键ID self.hotkey_ids = {} # 通知设置 self.notification_enabled = True # 浮窗状态：0-显示浮窗1，1-显示浮窗2，2-都隐藏 self.window_state = 0 # 临时文件路径 self.temp_file = os.path.join(tempfile.gettempdir(), \u0026#34;project_countdown_config.json\u0026#34;) logging.info(f\u0026#34;配置文件路径: {self.temp_file}\u0026#34;) # 尝试加载配置 self.load_config() # 创建主窗口（隐藏） self.root = tk.Tk() self.root.withdraw() # 创建两个浮窗 self.create_overlay1() # 浮窗1：详细倒计时 self.create_overlay2() # 浮窗2：状态指示 # 初始化浮窗状态 self.update_window_state() # 创建系统托盘 self.create_system_tray() # 绑定全局快捷键 self.bind_global_hotkeys() # 启动倒计时更新线程 self.update_thread = threading.Thread(target=self.update_countdowns, daemon=True) self.update_thread.start() logging.info(\u0026#34;倒计时更新线程已启动\u0026#34;) # 启动配置保存线程 self.save_thread = threading.Thread(target=self.periodic_save, daemon=True) self.save_thread.start() logging.info(\u0026#34;配置保存线程已启动\u0026#34;) def bind_global_hotkeys(self): \u0026#34;\u0026#34;\u0026#34;绑定全局快捷键\u0026#34;\u0026#34;\u0026#34; try: self.unbind_all_hotkeys() # 绑定切换浮窗状态快捷键 if self.is_valid_hotkey(self.hotkeys[\u0026#39;toggle_windows\u0026#39;]): hotkey_id = keyboard.add_hotkey( self.hotkeys[\u0026#39;toggle_windows\u0026#39;], self.cycle_window_state ) self.hotkey_ids[\u0026#39;toggle_windows\u0026#39;] = hotkey_id logging.info(f\u0026#34;已绑定切换浮窗快捷键: {self.hotkeys[\u0026#39;toggle_windows\u0026#39;]}\u0026#34;) else: logging.error(f\u0026#34;无效的快捷键格式: {self.hotkeys[\u0026#39;toggle_windows\u0026#39;]}，使用默认值\u0026#34;) self.hotkeys[\u0026#39;toggle_windows\u0026#39;] = \u0026#39;ctrl+shift+q\u0026#39; self.bind_global_hotkeys() # 绑定打开设置窗口快捷键 if self.is_valid_hotkey(self.hotkeys[\u0026#39;open_settings\u0026#39;]): hotkey_id = keyboard.add_hotkey( self.hotkeys[\u0026#39;open_settings\u0026#39;], self.open_config_window ) self.hotkey_ids[\u0026#39;open_settings\u0026#39;] = hotkey_id logging.info(f\u0026#34;已绑定打开设置窗口快捷键: {self.hotkeys[\u0026#39;open_settings\u0026#39;]}\u0026#34;) else: logging.error(f\u0026#34;无效的快捷键格式: {self.hotkeys[\u0026#39;open_settings\u0026#39;]}，使用默认值\u0026#34;) self.hotkeys[\u0026#39;open_settings\u0026#39;] = \u0026#39;ctrl+shift+s\u0026#39; self.bind_global_hotkeys() except Exception as e: logging.error(f\u0026#34;绑定快捷键失败: {str(e)}\u0026#34;) def is_valid_hotkey(self, hotkey): \u0026#34;\u0026#34;\u0026#34;验证快捷键格式是否有效\u0026#34;\u0026#34;\u0026#34; try: keyboard.parse_hotkey(hotkey) return True except: return False def unbind_all_hotkeys(self): \u0026#34;\u0026#34;\u0026#34;解除所有快捷键绑定\u0026#34;\u0026#34;\u0026#34; try: for action, hotkey_id in self.hotkey_ids.items(): if hotkey_id: keyboard.remove_hotkey(hotkey_id) self.hotkey_ids.clear() except Exception as e: logging.warning(f\u0026#34;解除快捷键绑定时出错: {str(e)}\u0026#34;) try: keyboard.unhook_all_hotkeys() except: pass def cycle_window_state(self): \u0026#34;\u0026#34;\u0026#34;循环切换浮窗状态：浮窗1→浮窗2→隐藏→浮窗1...\u0026#34;\u0026#34;\u0026#34; self.window_state = (self.window_state + 1) % 3 self.update_window_state() state_names = [\u0026#34;显示浮窗1\u0026#34;, \u0026#34;显示浮窗2\u0026#34;, \u0026#34;隐藏所有浮窗\u0026#34;] logging.info(f\u0026#34;浮窗状态切换为: {state_names[self.window_state]}\u0026#34;) def update_window_state(self): \u0026#34;\u0026#34;\u0026#34;根据当前状态更新浮窗显示\u0026#34;\u0026#34;\u0026#34; if self.window_state == 0: # 显示浮窗1 self.overlay1.deiconify() self.overlay2.withdraw() elif self.window_state == 1: # 显示浮窗2 self.overlay1.withdraw() self.overlay2.deiconify() else: # 都隐藏 self.overlay1.withdraw() self.overlay2.withdraw() def create_overlay1(self): \u0026#34;\u0026#34;\u0026#34;创建浮窗1（显示所有项目详细倒计时）\u0026#34;\u0026#34;\u0026#34; self.overlay1 = tk.Toplevel(self.root) self.overlay1.overrideredirect(True) # 无边框 self.overlay1.attributes(\u0026#39;-alpha\u0026#39;, 0.8) # 透明度 self.overlay1.attributes(\u0026#39;-topmost\u0026#39;, True) # 始终在最前面 self.overlay1.configure(bg=\u0026#39;black\u0026#39;) # 双击浮窗打开配置界面 self.overlay1.bind(\u0026#34;\u0026lt;Double-Button-1\u0026gt;\u0026#34;, lambda e: self.open_config_window()) # 创建两列布局 frame1 = tk.Frame(self.overlay1, bg=\u0026#39;black\u0026#39;) frame1.pack(side=tk.LEFT, padx=5, pady=5) frame2 = tk.Frame(self.overlay1, bg=\u0026#39;black\u0026#39;) frame2.pack(side=tk.LEFT, padx=5, pady=5) # 项目标签字典 self.labels = {} # 第一列项目 column1 = [\u0026#34;建一\u0026#34;, \u0026#34;建二\u0026#34;, \u0026#34;盾兵\u0026#34;, \u0026#34;矛兵\u0026#34;, \u0026#34;射手\u0026#34;, \u0026#34;科技\u0026#34;, \u0026#34;捐献\u0026#34;, \u0026#34;仓库\u0026#34;] for i, project in enumerate(column1): frame = tk.Frame(frame1, bg=\u0026#39;black\u0026#39;) frame.grid(row=i, column=0, sticky=\u0026#39;w\u0026#39;, pady=2) label = tk.Label(frame, text=f\u0026#34;{project}: \u0026#34;, bg=\u0026#39;black\u0026#39;, fg=\u0026#39;white\u0026#39;, font=(\u0026#39;SimHei\u0026#39;, 10, \u0026#39;bold\u0026#39;)) label.pack(side=tk.LEFT) # 确保能显示\u0026#34;99时59分59秒\u0026#34; time_label = tk.Label(frame, text=\u0026#34;未设置\u0026#34;, bg=\u0026#39;black\u0026#39;, fg=\u0026#39;gray\u0026#39;, font=(\u0026#39;SimHei\u0026#39;, 10), width=12) time_label.pack(side=tk.LEFT) self.labels[project] = frame, time_label # 第二列项目 column2 = [\u0026#34;行军一\u0026#34;, \u0026#34;行军二\u0026#34;, \u0026#34;行军三\u0026#34;, \u0026#34;行军四\u0026#34;, \u0026#34;行军五\u0026#34;] for i, project in enumerate(column2): frame = tk.Frame(frame2, bg=\u0026#39;black\u0026#39;) frame.grid(row=i, column=0, sticky=\u0026#39;w\u0026#39;, pady=2) label = tk.Label(frame, text=f\u0026#34;{project}: \u0026#34;, bg=\u0026#39;black\u0026#39;, fg=\u0026#39;white\u0026#39;, font=(\u0026#39;SimHei\u0026#39;, 10, \u0026#39;bold\u0026#39;)) label.pack(side=tk.LEFT) time_label = tk.Label(frame, text=\u0026#34;未设置\u0026#34;, bg=\u0026#39;black\u0026#39;, fg=\u0026#39;gray\u0026#39;, font=(\u0026#39;SimHei\u0026#39;, 10), width=12) time_label.pack(side=tk.LEFT) self.labels[project] = frame, time_label # 调整窗口大小 self.overlay1.update_idletasks() width = self.overlay1.winfo_width() height = self.overlay1.winfo_height() self.overlay1.geometry(f\u0026#34;{width}x{height}+100+100\u0026#34;) # 允许拖动窗口 self.overlay1.bind(\u0026#34;\u0026lt;Button-1\u0026gt;\u0026#34;, self.start_drag_overlay1) self.overlay1.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.on_drag_overlay1) logging.info(\u0026#34;浮窗1创建完成\u0026#34;) def create_overlay2(self): \u0026#34;\u0026#34;\u0026#34;创建浮窗2（20*20正方形半透明状态指示）\u0026#34;\u0026#34;\u0026#34; self.overlay2 = tk.Toplevel(self.root) self.overlay2.overrideredirect(True) # 无边框 self.overlay2.attributes(\u0026#39;-alpha\u0026#39;, 0.9) # 半透明 self.overlay2.attributes(\u0026#39;-topmost\u0026#39;, True) # 始终在最前面 self.overlay2.geometry(\u0026#34;30x30+300+200\u0026#34;) # 20*20大小，位置错开 # 状态指示标签 self.indicator = tk.Label(self.overlay2, bg=\u0026#39;gray\u0026#39;) self.indicator.pack(fill=tk.BOTH, expand=True) # 双击浮窗打开配置界面 self.overlay2.bind(\u0026#34;\u0026lt;Double-Button-1\u0026gt;\u0026#34;, lambda e: self.open_config_window()) # 允许拖动窗口 self.overlay2.bind(\u0026#34;\u0026lt;Button-1\u0026gt;\u0026#34;, self.start_drag_overlay2) self.overlay2.bind(\u0026#34;\u0026lt;B1-Motion\u0026gt;\u0026#34;, self.on_drag_overlay2) logging.info(\u0026#34;浮窗2创建完成\u0026#34;) def start_drag_overlay1(self, event): \u0026#34;\u0026#34;\u0026#34;开始拖动浮窗1\u0026#34;\u0026#34;\u0026#34; self.x1 = event.x self.y1 = event.y def on_drag_overlay1(self, event): \u0026#34;\u0026#34;\u0026#34;拖动浮窗1时更新位置\u0026#34;\u0026#34;\u0026#34; x = self.overlay1.winfo_x() + event.x - self.x1 y = self.overlay1.winfo_y() + event.y - self.y1 self.overlay1.geometry(f\u0026#34;+{x}+{y}\u0026#34;) logging.debug(f\u0026#34;浮窗1位置更新: x={x}, y={y}\u0026#34;) def start_drag_overlay2(self, event): \u0026#34;\u0026#34;\u0026#34;开始拖动浮窗2\u0026#34;\u0026#34;\u0026#34; self.x2 = event.x self.y2 = event.y def on_drag_overlay2(self, event): \u0026#34;\u0026#34;\u0026#34;拖动浮窗2时更新位置\u0026#34;\u0026#34;\u0026#34; x = self.overlay2.winfo_x() + event.x - self.x2 y = self.overlay2.winfo_y() + event.y - self.y2 self.overlay2.geometry(f\u0026#34;+{x}+{y}\u0026#34;) logging.debug(f\u0026#34;浮窗2位置更新: x={x}, y={y}\u0026#34;) def create_system_tray(self): \u0026#34;\u0026#34;\u0026#34;创建系统托盘图标和菜单\u0026#34;\u0026#34;\u0026#34; try: # 创建简单图标 image = Image.new(\u0026#39;RGB\u0026#39;, (64, 64), color=\u0026#39;blue\u0026#39;) draw = ImageDraw.Draw(image) draw.text((10, 20), \u0026#34;倒\u0026#34;, font_size=20, fill=\u0026#39;white\u0026#39;) # 创建菜单 menu = ( item(\u0026#39;显示浮窗1\u0026#39;, lambda icon, item: self.set_window_state(0)), item(\u0026#39;显示浮窗2\u0026#39;, lambda icon, item: self.set_window_state(1)), item(\u0026#39;隐藏所有\u0026#39;, lambda icon, item: self.set_window_state(2)), item(\u0026#39;设置倒计时\u0026#39;, lambda icon, item: self.open_config_window()), item(\u0026#39;退出\u0026#39;, lambda icon, item: self.exit_app()) ) # 创建托盘图标 self.tray = pystray.Icon(\u0026#34;project_countdown\u0026#34;, image, \u0026#34;项目倒计时\u0026#34;, menu) logging.info(\u0026#34;系统托盘创建完成\u0026#34;) # 在单独线程中运行托盘 threading.Thread(target=self.tray.run, daemon=True).start() except Exception as e: logging.error(f\u0026#34;创建系统托盘失败: {str(e)}\u0026#34;) def set_window_state(self, state): \u0026#34;\u0026#34;\u0026#34;设置浮窗状态\u0026#34;\u0026#34;\u0026#34; self.window_state = state self.update_window_state() def open_config_window(self, *args): \u0026#34;\u0026#34;\u0026#34;打开配置窗口\u0026#34;\u0026#34;\u0026#34; logging.info(\u0026#34;打开配置窗口\u0026#34;) # 确保浮窗1可见 self.set_window_state(0) # 如果窗口已存在则激活它 if hasattr(self, \u0026#39;config_window\u0026#39;) and isinstance(self.config_window, tk.Toplevel) and self.config_window.winfo_exists(): self.config_window.lift() return # 创建配置窗口 self.config_window = tk.Toplevel(self.overlay1) self.config_window.title(\u0026#34;设置倒计时与快捷键\u0026#34;) self.config_window.geometry(\u0026#34;700x650\u0026#34;) self.config_window.attributes(\u0026#39;-topmost\u0026#39;, True) # 创建带滚动条的主框架 main_frame = ttk.Frame(self.config_window) main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10) # 创建笔记本控件（标签页） notebook = ttk.Notebook(main_frame) notebook.pack(fill=tk.BOTH, expand=True) # 倒计时设置标签页 countdown_frame = ttk.Frame(notebook) notebook.add(countdown_frame, text=\u0026#34;倒计时设置\u0026#34;) # 快捷键设置标签页 hotkey_frame = ttk.Frame(notebook) notebook.add(hotkey_frame, text=\u0026#34;快捷键设置\u0026#34;) # 通知设置标签页 notify_frame = ttk.Frame(notebook) notebook.add(notify_frame, text=\u0026#34;通知设置\u0026#34;) # ============== 倒计时设置标签页内容 ============== canvas = tk.Canvas(countdown_frame) scrollbar = ttk.Scrollbar(countdown_frame, orient=\u0026#34;vertical\u0026#34;, command=canvas.yview) scrollable_frame = ttk.Frame(canvas) scrollable_frame.bind( \u0026#34;\u0026lt;Configure\u0026gt;\u0026#34;, lambda e: canvas.configure(scrollregion=canvas.bbox(\u0026#34;all\u0026#34;)) ) canvas.create_window((0, 0), window=scrollable_frame, anchor=\u0026#34;nw\u0026#34;) canvas.configure(yscrollcommand=scrollbar.set) canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True) scrollbar.pack(side=tk.RIGHT, fill=tk.Y) # 存储输入框引用 self.time_entries = {} # 添加所有项目的输入框 for i, project in enumerate(self.projects.keys()): row_frame = ttk.Frame(scrollable_frame) row_frame.grid(row=i, column=0, padx=5, pady=5, sticky=\u0026#34;ew\u0026#34;) ttk.Label(row_frame, text=project, width=10).grid(row=0, column=0, padx=5) hour_entry = ttk.Entry(row_frame, width=5) hour_entry.grid(row=0, column=1, padx=2) ttk.Label(row_frame, text=\u0026#34;时\u0026#34;).grid(row=0, column=2) min_entry = ttk.Entry(row_frame, width=5) min_entry.grid(row=0, column=3, padx=2) ttk.Label(row_frame, text=\u0026#34;分\u0026#34;).grid(row=0, column=4) sec_entry = ttk.Entry(row_frame, width=5) sec_entry.grid(row=0, column=5, padx=2) ttk.Label(row_frame, text=\u0026#34;秒\u0026#34;).grid(row=0, column=6) apply_btn = ttk.Button(row_frame, text=\u0026#34;应用\u0026#34;, command=lambda p=project, h=hour_entry, m=min_entry, s=sec_entry: self.apply_time(p, h, m, s)) apply_btn.grid(row=0, column=7, padx=10) clear_btn = ttk.Button(row_frame, text=\u0026#34;清除\u0026#34;, command=lambda p=project, h=hour_entry, m=min_entry, s=sec_entry: self.clear_time(p, h, m, s)) clear_btn.grid(row=0, column=8, padx=5) self.time_entries[project] = (hour_entry, min_entry, sec_entry) # 填充已设置的时间 hours, mins, secs = self.original_times[project] if hours \u0026gt; 0: hour_entry.insert(0, str(hours)) if mins \u0026gt; 0: min_entry.insert(0, str(mins)) if secs \u0026gt; 0: sec_entry.insert(0, str(secs)) # ============== 快捷键设置标签页内容 ============== ttk.Label(hotkey_frame, text=\u0026#34;请使用以下格式: ctrl+shift+q 或 alt+s\u0026#34;, font=(\u0026#39;SimHei\u0026#39;, 10, \u0026#39;bold\u0026#39;)).pack(pady=20) frame1 = ttk.Frame(hotkey_frame) frame1.pack(fill=tk.X, padx=20, pady=10) ttk.Label(frame1, text=\u0026#34;切换浮窗状态:\u0026#34;, width=20).pack(side=tk.LEFT) self.toggle_hotkey_var = tk.StringVar(value=self.hotkeys[\u0026#39;toggle_windows\u0026#39;]) ttk.Entry(frame1, textvariable=self.toggle_hotkey_var).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5) ttk.Button(frame1, text=\u0026#34;应用\u0026#34;, command=lambda: self.update_hotkey(\u0026#39;toggle_windows\u0026#39;, self.toggle_hotkey_var.get())).pack(side=tk.LEFT, padx=5) frame2 = ttk.Frame(hotkey_frame) frame2.pack(fill=tk.X, padx=20, pady=10) ttk.Label(frame2, text=\u0026#34;打开设置窗口:\u0026#34;, width=20).pack(side=tk.LEFT) self.settings_hotkey_var = tk.StringVar(value=self.hotkeys[\u0026#39;open_settings\u0026#39;]) ttk.Entry(frame2, textvariable=self.settings_hotkey_var).pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5) ttk.Button(frame2, text=\u0026#34;应用\u0026#34;, command=lambda: self.update_hotkey(\u0026#39;open_settings\u0026#39;, self.settings_hotkey_var.get())).pack(side=tk.LEFT, padx=5) ttk.Label(hotkey_frame, text=\u0026#34;支持的修饰键: ctrl, shift, alt；使用+连接；字母为小写\u0026#34;, foreground=\u0026#34;gray\u0026#34;).pack(pady=20) # ============== 通知设置标签页内容 ============== ttk.Label(notify_frame, text=\u0026#34;通知设置\u0026#34;, font=(\u0026#39;SimHei\u0026#39;, 12, \u0026#39;bold\u0026#39;)).pack(pady=20) self.notify_var = tk.BooleanVar(value=self.notification_enabled) notify_check = ttk.Checkbutton( notify_frame, text=\u0026#34;任务到期时启用通知\u0026#34;, variable=self.notify_var, command=self.update_notification_setting ) notify_check.pack(anchor=tk.W, padx=20, pady=10) def update_notification_setting(self): \u0026#34;\u0026#34;\u0026#34;更新通知设置\u0026#34;\u0026#34;\u0026#34; self.notification_enabled = self.notify_var.get() logging.info(f\u0026#34;通知设置已更新: {\u0026#39;启用\u0026#39; if self.notification_enabled else \u0026#39;禁用\u0026#39;}\u0026#34;) def update_hotkey(self, action, new_hotkey): \u0026#34;\u0026#34;\u0026#34;更新快捷键设置\u0026#34;\u0026#34;\u0026#34; try: if not re.match(r\u0026#39;^((ctrl|shift|alt)\\+)*[a-z]$\u0026#39;, new_hotkey, re.IGNORECASE): messagebox.showerror(\u0026#34;输入错误\u0026#34;, \u0026#34;请输入有效的快捷键格式，例如: ctrl+shift+q\u0026#34;) return new_hotkey = new_hotkey.lower() if not self.is_valid_hotkey(new_hotkey): messagebox.showerror(\u0026#34;输入错误\u0026#34;, f\u0026#34;快捷键 \u0026#39;{new_hotkey}\u0026#39; 无效，请尝试其他组合\u0026#34;) return self.hotkeys[action] = new_hotkey self.bind_global_hotkeys() logging.info(f\u0026#34;快捷键已更新: {action} -\u0026gt; {self.hotkeys[action]}\u0026#34;) messagebox.showinfo(\u0026#34;成功\u0026#34;, f\u0026#34;快捷键已更新为: {self.hotkeys[action]}\u0026#34;) except Exception as e: logging.error(f\u0026#34;更新快捷键失败: {str(e)}\u0026#34;) messagebox.showerror(\u0026#34;错误\u0026#34;, f\u0026#34;更新快捷键失败: {str(e)}\u0026#34;) def apply_time(self, project, hour_entry, min_entry, sec_entry): \u0026#34;\u0026#34;\u0026#34;应用设置的时间\u0026#34;\u0026#34;\u0026#34; try: hours = int(hour_entry.get() or 0) mins = int(min_entry.get() or 0) secs = int(sec_entry.get() or 0) if hours \u0026lt; 0 or hours \u0026gt; 99 or mins \u0026lt; 0 or mins \u0026gt;= 60 or secs \u0026lt; 0 or secs \u0026gt;= 60: messagebox.showerror(\u0026#34;输入错误\u0026#34;, \u0026#34;请输入有效的时间值！\\n小时0-99，分钟和秒0-59\u0026#34;) return total_seconds = hours * 3600 + mins * 60 + secs if total_seconds \u0026lt;= 0: messagebox.showinfo(\u0026#34;提示\u0026#34;, \u0026#34;时间必须大于0\u0026#34;) return end_time = datetime.datetime.now() + datetime.timedelta(seconds=total_seconds) self.projects[project] = end_time self.elapsed_start[project] = None self.notification_sent[project] = False # 重置通知状态 self.original_times[project] = (hours, mins, secs) # 更新输入框显示 hour_entry.delete(0, tk.END) min_entry.delete(0, tk.END) sec_entry.delete(0, tk.END) hour_entry.insert(0, str(hours)) min_entry.insert(0, str(mins)) sec_entry.insert(0, str(secs)) logging.info(f\u0026#34;项目 [{project}] 倒计时已设置: {hours}时{mins}分{secs}秒\u0026#34;) except ValueError: messagebox.showerror(\u0026#34;输入错误\u0026#34;, \u0026#34;请输入有效的数字\u0026#34;) except Exception as e: logging.error(f\u0026#34;应用时间设置失败: {str(e)}\u0026#34;) def clear_time(self, project, hour_entry, min_entry, sec_entry): \u0026#34;\u0026#34;\u0026#34;清除项目的倒计时\u0026#34;\u0026#34;\u0026#34; self.projects[project] = None self.original_times[project] = (0, 0, 0) self.elapsed_start[project] = None self.notification_sent[project] = False # 清除输入框 hour_entry.delete(0, tk.END) min_entry.delete(0, tk.END) sec_entry.delete(0, tk.END) logging.info(f\u0026#34;项目 [{project}] 倒计时已清除\u0026#34;) def calculate_time_status(self, project): \u0026#34;\u0026#34;\u0026#34;计算项目的时间状态：剩余时间或已过时间\u0026#34;\u0026#34;\u0026#34; end_time = self.projects.get(project) if end_time is None: return (\u0026#34;未设置\u0026#34;, None) now = datetime.datetime.now() if end_time \u0026lt; now: # 如果是刚到期，记录正计时开始时间 if self.elapsed_start[project] is None: self.elapsed_start[project] = now logging.info(f\u0026#34;项目 [{project}] 已到期\u0026#34;) # 计算已过时间 elapsed = now - self.elapsed_start[project] return (\u0026#34;elapsed\u0026#34;, int(elapsed.total_seconds())) else: # 计算剩余时间 remaining = end_time - now return (\u0026#34;remaining\u0026#34;, int(remaining.total_seconds())) def check_for_expired_projects(self): \u0026#34;\u0026#34;\u0026#34;检查是否有超期项目\u0026#34;\u0026#34;\u0026#34; for project in self.projects: status, _ = self.calculate_time_status(project) if status == \u0026#34;elapsed\u0026#34;: return True return False def get_min_remaining_time(self): \u0026#34;\u0026#34;\u0026#34;获取所有项目中最小的剩余时间（秒）\u0026#34;\u0026#34;\u0026#34; min_remaining = None for project in self.projects: status, seconds = self.calculate_time_status(project) if status == \u0026#34;remaining\u0026#34; and seconds is not None: if min_remaining is None or seconds \u0026lt; min_remaining: min_remaining = seconds return min_remaining def update_overlay2_color(self): \u0026#34;\u0026#34;\u0026#34;根据项目状态更新浮窗2颜色\u0026#34;\u0026#34;\u0026#34; # 浮窗2颜色逻辑： # 1. 存在超期项目 → 红色 # 2. 无超期但存在≤2分钟的项目 → 黄色 # 3. 所有项目\u0026gt;2分钟 → 绿色 # 4. 无有效项目 → 灰色 if self.check_for_expired_projects(): self.indicator.configure(bg=\u0026#39;red\u0026#39;) else: min_remaining = self.get_min_remaining_time() if min_remaining is None: self.indicator.configure(bg=\u0026#39;gray\u0026#39;) elif min_remaining \u0026gt; 120: # \u0026gt;2分钟 self.indicator.configure(bg=\u0026#39;green\u0026#39;) elif 0 \u0026lt; min_remaining \u0026lt;= 120: # ≤2分钟 self.indicator.configure(bg=\u0026#39;yellow\u0026#39;) else: # ≤2分钟但\u0026gt;0 self.indicator.configure(bg=\u0026#39;yellow\u0026#39;) def send_notification(self, project): \u0026#34;\u0026#34;\u0026#34;发送系统通知\u0026#34;\u0026#34;\u0026#34; if not self.notification_enabled or self.notification_sent[project]: return try: notification.notify( title=\u0026#34;项目倒计时\u0026#34;, message=f\u0026#34;项目 \u0026#39;{project}\u0026#39; 已到期！\u0026#34;, timeout=10 ) self.notification_sent[project] = True logging.info(f\u0026#34;已发送项目 [{project}] 到期通知\u0026#34;) except Exception as e: logging.error(f\u0026#34;发送通知失败: {str(e)}\u0026#34;) def format_time(self, status, seconds): \u0026#34;\u0026#34;\u0026#34;格式化时间显示\u0026#34;\u0026#34;\u0026#34; if status != \u0026#34;remaining\u0026#34; and status != \u0026#34;elapsed\u0026#34;: return \u0026#34;未设置\u0026#34; days = seconds // 86400 seconds %= 86400 hours = seconds // 3600 seconds %= 3600 mins = seconds // 60 secs = seconds % 60 if days \u0026gt; 0: return f\u0026#34;{days}天{hours}时{mins}分{secs}秒\u0026#34; else: return f\u0026#34;{hours:02d}时{mins:02d}分{secs:02d}秒\u0026#34; def update_countdowns(self): \u0026#34;\u0026#34;\u0026#34;更新所有项目的倒计时显示，每秒更新一次\u0026#34;\u0026#34;\u0026#34; while True: try: # 更新浮窗1项目状态 for project, (row_frame, time_label) in self.labels.items(): status, seconds = self.calculate_time_status(project) # 如果项目刚到期且需要通知，发送通知 if status == \u0026#34;elapsed\u0026#34; and seconds \u0026lt;= 1 and not self.notification_sent[project]: self.send_notification(project) time_str = self.format_time(status, seconds) # 设置颜色 if status == \u0026#34;remaining\u0026#34;: if seconds \u0026gt; 120: # \u0026gt;2分钟 color = \u0026#34;green\u0026#34; else: # ≤2分钟 color = \u0026#34;yellow\u0026#34; elif status == \u0026#34;elapsed\u0026#34;: color = \u0026#34;red\u0026#34; else: color = \u0026#34;gray\u0026#34; # 更新UI self.overlay1.after(0, lambda rf=row_frame: rf.configure(bg=\u0026#39;black\u0026#39;)) self.overlay1.after(0, lambda tl=time_label, t=time_str, c=color: tl.config(text=t, fg=c)) # 更新浮窗2颜色 self.root.after(0, self.update_overlay2_color) time.sleep(1) except Exception as e: logging.error(f\u0026#34;更新倒计时时出错: {str(e)}\u0026#34;) time.sleep(1) def save_config(self): \u0026#34;\u0026#34;\u0026#34;保存配置到临时文件\u0026#34;\u0026#34;\u0026#34; try: data = { \u0026#34;projects\u0026#34;: {}, \u0026#34;original_times\u0026#34;: {}, \u0026#34;hotkeys\u0026#34;: self.hotkeys, \u0026#34;notification_enabled\u0026#34;: self.notification_enabled } # 保存项目结束时间 for project, end_time in self.projects.items(): if end_time is not None and end_time \u0026gt; datetime.datetime.now(): data[\u0026#34;projects\u0026#34;][project] = end_time.isoformat() # 保存原始时间设置 for project, (h, m, s) in self.original_times.items(): if h \u0026gt; 0 or m \u0026gt; 0 or s \u0026gt; 0: data[\u0026#34;original_times\u0026#34;][project] = (h, m, s) # 写入临时文件 with open(self.temp_file, \u0026#34;w\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: json.dump(data, f, ensure_ascii=False, indent=2) logging.debug(\u0026#34;配置已保存\u0026#34;) except Exception as e: logging.error(f\u0026#34;保存配置失败: {str(e)}\u0026#34;) def load_config(self): \u0026#34;\u0026#34;\u0026#34;从临时文件加载配置\u0026#34;\u0026#34;\u0026#34; if not os.path.exists(self.temp_file): logging.info(\u0026#34;没有找到配置文件，使用默认配置\u0026#34;) return try: with open(self.temp_file, \u0026#34;r\u0026#34;, encoding=\u0026#34;utf-8\u0026#34;) as f: data = json.load(f) # 加载项目结束时间 if \u0026#34;projects\u0026#34; in data: for project, time_str in data[\u0026#34;projects\u0026#34;].items(): if project in self.projects: end_time = datetime.datetime.fromisoformat(time_str) # 只加载未来的时间 if end_time \u0026gt; datetime.datetime.now(): self.projects[project] = end_time logging.debug(f\u0026#34;已加载项目 [{project}] 的倒计时配置\u0026#34;) # 加载原始时间设置 if \u0026#34;original_times\u0026#34; in data: for project, (h, m, s) in data[\u0026#34;original_times\u0026#34;].items(): if project in self.original_times: self.original_times[project] = (h, m, s) # 加载快捷键设置 if \u0026#34;hotkeys\u0026#34; in data: for action, hotkey in data[\u0026#34;hotkeys\u0026#34;].items(): if action in self.hotkeys and self.is_valid_hotkey(hotkey): self.hotkeys[action] = hotkey # 加载通知设置 if \u0026#34;notification_enabled\u0026#34; in data: self.notification_enabled = data[\u0026#34;notification_enabled\u0026#34;] logging.info(\u0026#34;配置加载完成\u0026#34;) except Exception as e: logging.error(f\u0026#34;加载配置失败: {str(e)}\u0026#34;) try: os.remove(self.temp_file) logging.info(\u0026#34;已删除损坏的配置文件\u0026#34;) except: pass def periodic_save(self): \u0026#34;\u0026#34;\u0026#34;定期保存配置，每30秒一次\u0026#34;\u0026#34;\u0026#34; while True: self.save_config() time.sleep(30) def exit_app(self): \u0026#34;\u0026#34;\u0026#34;退出应用程序\u0026#34;\u0026#34;\u0026#34; logging.info(\u0026#34;准备退出程序\u0026#34;) # 退出前保存一次配置 self.save_config() # 停止托盘 self.tray.stop() # 关闭配置窗口 if hasattr(self, \u0026#39;config_window\u0026#39;) and isinstance(self.config_window, tk.Toplevel) and self.config_window.winfo_exists(): self.config_window.destroy() # 关闭浮窗和主窗口 self.overlay1.destroy() self.overlay2.destroy() self.root.destroy() # 停止全局快捷键监听 try: keyboard.unhook_all() except: pass logging.info(\u0026#34;程序已退出\u0026#34;) os._exit(0) if __name__ == \u0026#34;__main__\u0026#34;: try: app = ProjectCountdownApp() app.root.mainloop() except Exception as e: logging.critical(f\u0026#34;程序运行出错: {str(e)}\u0026#34;, exc_info=True) os._exit(1) ","date":"2025-08-20T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/%E6%97%A0%E5%B0%BD%E5%86%AC%E6%97%A5%E8%AE%A1%E6%97%B6%E5%99%A8%E5%B7%A5%E5%85%B7/","title":"无尽冬日计时器工具"},{"content":" 资源计算器 高效计算和管理各类资源\n计时器","date":"2025-08-20T00:33:55+08:00","permalink":"https://blog-g.leecq.cn/p/%E5%B0%8F%E5%B7%A5%E5%85%B7/","title":"小工具"},{"content":"Aliyun快速创建ECS实例 - Clash 设置合适的安全组 在控制台中设置安全组并记录组ID：开放22, 80, 443, 3389端口。\n编写启动脚本 克隆项目，或从OSS下载启动文件, 。 从蓝奏云上下载数据，并部署\n1 自定义 运行实例 使用模板或者使用自定义参数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \u0026#34;RegionId\u0026#34;: \u0026#34;cn-shenzhen\u0026#34;, # 区域 \u0026#34;InstanceType\u0026#34;: \u0026#34;ecs.e-c1m1.large\u0026#34;, \u0026#34;ImageId\u0026#34;: \u0026#34;ubuntu_24_04_x64_20G_alibase_20250113.vhd\u0026#34;, \u0026#34;SystemDisk.Size\u0026#34;: 20, # 系统盘大小 \u0026#34;SystemDisk.Category\u0026#34;: \u0026#34;cloud_essd_entry\u0026#34;, # 系统盘类型 \u0026#34;SecurityEnhancementStrategy\u0026#34;: \u0026#34;Active\u0026#34;, # 安全加固Active：启用安全加固，Deactive：不启用安全加固 \u0026#34;InstanceChargeType\u0026#34;: \u0026#34;PostPaid\u0026#34;, # 实例计费类型 - 后付费 \u0026#34;SpotStrategy\u0026#34;: \u0026#34;SpotAsPriceGo\u0026#34;, # 按量付费实例的竞价策略。SpotAsPriceGo - 系统自动出价，跟随当前市场实际价格 \u0026#34;SpotInterruptionBehavior\u0026#34;: \u0026#34;Terminate\u0026#34;, # 抢占实例中断模式。 Terminate：直接释放实例。 \u0026#34;InternetChargeType\u0026#34;: \u0026#34;PayByTraffic\u0026#34;, # 网络计费类型，按流量 \u0026#34;AutoRenew\u0026#34;: false, # 自动续费 \u0026#34;InternetMaxBandwidthIn\u0026#34;: 100, \u0026#34;InternetMaxBandwidthOut\u0026#34;: 10, # 出带宽大于0 自动分配公网IP \u0026#34;VSwitchId\u0026#34;: \u0026#34;vsw-wz9q3hnkysu1p4sc*****\u0026#34;, # 绑定交换机 \u0026#34;SecurityGroupId\u0026#34;: \u0026#34;sg-wz9etfd2xhsxa1p*****\u0026#34;, # 绑定安全组 \u0026#34;ResourceGroupId\u0026#34;: \u0026#34;rg-acfmvpl4ra*****\u0026#34;, # 资源组 \u0026#34;InstanceName\u0026#34;: \u0026#34;api-test\u0026#34;, # 实例名字 \u0026#34;HostName\u0026#34;: \u0026#34;api-test\u0026#34;, # 主机名 \u0026#34;Password\u0026#34;: \u0026#34;****\u0026#34;, # 密码 \u0026#34;UserData\u0026#34;: \u0026#34;Iy9iaW4vYmFzaAplY2hvICJzdGFydCBFQ1MiID4gdGVzdC50eHQ=\u0026#34;, # 用户脚本 \u0026#34;DryRun\u0026#34;: false, # 测试运行 } Aliyun CLI 参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 user_data=\u0026#34;Iy9iaW4vYmFzaAplY2hvICJzdGFydCBFQ1MiID4gdGVzdC50eHQ\u0026#34; ecs_password=\u0026#34;*******\u0026#34; relase_time=$(date --date=\u0026#34;@$(date -d \u0026#39;+4 hours\u0026#39; +%s)\u0026#34; +\u0026#39;%Y-%m-%dT%H:%M:%SZ\u0026#39; -u) # 获取4小时后的UTC时间 # 查询价格 aliyun ecs DescribePrice --force --RegionId cn-shenzhen --ImageId \u0026#34;ubuntu_24_04_x64_20G_alibase_20250113.vhd\u0026#34; \\ --InstanceType \u0026#34;ecs.e-c1m1.large\u0026#34; --SystemDisk.Category cloud_essd_entry --SystemDisk.Size 20 \\ --InstanceChargeType PostPaid --SpotStrategy SpotAsPriceGo --SpotInterruptionBehavior Terminate \\ --InternetChargeType PayByTraffic --InternetMaxBandwidthOut 10 --InternetMaxBandwidthIn 100 \\ --VSwitchId vsw-wz9q3hnkysu1p4scm**** --SecurityGroupId sg-wz9etfd2xhsxa1p**** \\ --HostName \u0026#34;api-test\u0026#34; --Password \u0026#34;${ecs_password}\u0026#34; --DryRun true # 创建实例 ecs_password=\u0026#34;*******\u0026#34; aliyun ecs RunInstances --RegionId cn-shenzhen --ImageId \u0026#34;ubuntu_24_04_x64_20G_alibase_20250113.vhd\u0026#34; \\ --InstanceType \u0026#34;ecs.e-c1m1.large\u0026#34; --SystemDisk.Category cloud_essd_entry --SystemDisk.Size 20 \\ --InstanceChargeType PostPaid --SpotStrategy SpotAsPriceGo --SpotInterruptionBehavior Terminate \\ --InternetChargeType PayByTraffic --InternetMaxBandwidthOut 10 --InternetMaxBandwidthIn 100 \\ --VSwitchId vsw-wz9q3hnkysu1p4scm**** --SecurityGroupId sg-wz9etfd2xhsxa1p**** \\ --HostName \u0026#34;api-test\u0026#34; --Password \u0026#34;${ecs_password}\u0026#34; --UserData ${user_data} --AutoReleaseTime ${relase_time} \\ --DryRun true 返回结果：{ \u0026ldquo;InstanceIdSets\u0026rdquo;: { \u0026ldquo;InstanceIdSet\u0026rdquo;: [ \u0026ldquo;i-wz91g5uy6dgm8gas****\u0026rdquo; ] }, \u0026ldquo;RequestId\u0026rdquo;: \u0026ldquo;C449D45D-CC95-5BDD-9438-9DD139679A48\u0026rdquo; }\n得到实例ID： jq -r '.InstanceIdSets.InstanceIdSet[0]\n分配IP地址 使用StartInstance创建实例时，需要手动调用分配公网IP API（出带宽必须大于0）； 使用RunInstancesces创建实例时，当出带宽打于0时，自动分配IP。\n查询ECS信息 调用查询接口\n1 aliyun ecs DescribeInstanceAttribute --region cn-shenzhen --InstanceId \u0026#39;i-wz91g5uy6dgm8gas****\u0026#39; 返回：{ \u0026ldquo;ClusterId\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026ldquo;Cpu\u0026rdquo;: 2, \u0026ldquo;CreationTime\u0026rdquo;: \u0026ldquo;2025-02-15T09:52:38Z\u0026rdquo;, \u0026ldquo;CreditSpecification\u0026rdquo;: \u0026ldquo;\u0026rdquo;, \u0026hellip;\u0026hellip; \u0026ldquo;Memory\u0026rdquo;: 2048, \u0026ldquo;OperationLocks\u0026rdquo;: { \u0026ldquo;LockReason\u0026rdquo;: [] }, \u0026ldquo;PublicIpAddress\u0026rdquo;: { \u0026ldquo;IpAddress\u0026rdquo;: [ \u0026ldquo;47.119.180.220\u0026rdquo; ] }, \u0026ldquo;RegionId\u0026rdquo;: \u0026ldquo;cn-shenzhen\u0026rdquo;, \u0026hellip;\u0026hellip; }, \u0026ldquo;ZoneId\u0026rdquo;: \u0026ldquo;cn-shenzhen-e\u0026rdquo; }\n查询公网IP地址。aliyun ecs DescribeInstanceAttribute \u0026ndash;InstanceId \u0026lsquo;i-wz91g5uy6dgm8gas****\u0026rsquo; |jq .PublicIpAddress.IpAddress[0] -r\n更新DNS到主机 更新IP地址信息到DNSPOD。 1 2 3 4 5 curl -X POST https://dnsapi.cn/Record.Modify --header \u0026#39;User-Agent: HostCreate/v0.1(lee-cq@qq.com)\u0026#39; \\ -d \u0026#39;login_token=${LOGIN_TOKEN}\u0026amp;format=json\u0026amp;domain=${DOMAIN}\u0026amp;sub_domain=ali-host\u0026amp;record_type=A\u0026amp;record_line_id=10%3D0\u0026amp;value=${pub_ip}\u0026#39; # Aliyun DNS aliyun alidns AddDomainRecord --region cn-shenzhen --DomainName \u0026#39;DOMAIN\u0026#39; --RR \u0026#39;api-test\u0026#39; --Type A --Value ${pub_ip} 手动释放实例 1 2 3 4 5 6 7 8 aliyun ecs DeleteInstance --region cn-shenzhen --InstanceId \u0026#39;i-wz91g5uy6dgm8gasp6ac\u0026#39; --Force true # 强制释放实例 record_id=$(curl -X POST https://dnsapi.cn/Record.List --header \u0026#39;User-Agent: HostCreate/V0.1(lee-cq@qq.com)\u0026#39; \\ -d \u0026#39;login_token=${LOGIN_TOKEN}\u0026amp;format=json\u0026amp;domain_id=${DOMAIN}\u0026amp;sub_domain=ali-host\u0026#39; | jq -r \u0026#39;.records[0].id\u0026#39;) # 删除DNS解析 curl -X POST https://dnsapi.cn/Record.Remove --header \u0026#39;User-Agent: HostCreate/V0.1(lee-cq@qq.com)\u0026#39; \\ -d \u0026#39;login_token=${LOGIN_TOKEN}\u0026amp;format=json\u0026amp;domain=${DOMAIN}\u0026amp;record_id=${record_id}\u0026#39; 完整脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 user_data=\u0026#34;Iy9iaW4vYmFzaAplY2hvICJzdGFydCBFQ1MiID4gdGVzdC50eHQ\u0026#34; ecs_password=\u0026#34;*******\u0026#34; relase_time=$(date --date=\u0026#34;@$(date -d \u0026#39;+4 hours\u0026#39; +%s)\u0026#34; +\u0026#39;%Y-%m-%dT%H:%M:%SZ\u0026#39; -u) # 获取4小时后的UTC时间 DOMAIN=\u0026#34;\u0026#34; # 查询价格 aliyun ecs DescribePrice --force --RegionId cn-shenzhen --ImageId \u0026#34;ubuntu_24_04_x64_20G_alibase_20250113.vhd\u0026#34; \\ --InstanceType \u0026#34;ecs.e-c1m1.large\u0026#34; --SystemDisk.Category cloud_essd_entry --SystemDisk.Size 20 \\ --InstanceChargeType PostPaid --SpotStrategy SpotAsPriceGo --SpotInterruptionBehavior Terminate \\ --InternetChargeType PayByTraffic --InternetMaxBandwidthOut 10 --InternetMaxBandwidthIn 100 \\ --VSwitchId vsw-wz9q3hnkysu1p4scm**** --SecurityGroupId sg-wz9etfd2xhsxa1p**** \\ --HostName \u0026#34;api-test\u0026#34; --Password \u0026#34;${ecs_password}\u0026#34; --DryRun true # 创建实例 ecs_password=\u0026#34;*******\u0026#34; aliyun ecs RunInstances --RegionId cn-shenzhen --ImageId \u0026#34;ubuntu_24_04_x64_20G_alibase_20250113.vhd\u0026#34; \\ --InstanceType \u0026#34;ecs.e-c1m1.large\u0026#34; --SystemDisk.Category cloud_essd_entry --SystemDisk.Size 20 \\ --InstanceChargeType PostPaid --SpotStrategy SpotAsPriceGo --SpotInterruptionBehavior Terminate \\ --InternetChargeType PayByTraffic --InternetMaxBandwidthOut 10 --InternetMaxBandwidthIn 100 \\ --VSwitchId vsw-wz9q3hnkysu1p4scm**** --SecurityGroupId sg-wz9etfd2xhsxa1p**** \\ --HostName \u0026#34;api-test\u0026#34; --Password \u0026#34;${ecs_password}\u0026#34; --UserData ${user_data} \\ --AutoReleaseTime ${relase_time} | tee /dev/tty |jq -r \u0026#39;.InstanceIdSets.InstanceIdSet[0]\u0026#39; \u0026gt; ecs-instance-id # 查询公网IP地址 aliyun ecs DescribeInstanceAttribute --region cn-shenzhen --InstanceId \u0026#34;$(cat ecs-instance-id)\u0026#34; | tee /dev/tty | jq -r .PublicIpAddress.IpAddress[0] \u0026gt; ecs-instanse-ip # 将公网IP地址注册到DNSPOD curl -X POST https://dnsapi.cn/Record.Modify --header \u0026#39;User-Agent: HostCreate/v0.1(lee-cq@qq.com)\u0026#39; \\ -d \u0026#34;login_token=${LOGIN_TOKEN}\u0026amp;format=json\u0026amp;domain=${DOMAIN}\u0026amp;sub_domain=ali-host\u0026amp;record_type=A\u0026amp;record_line_id=10%3D0\u0026amp;value=$(cat ecs-instanse-ip)\u0026#34; ","date":"2025-02-15T17:24:41+08:00","permalink":"https://blog-g.leecq.cn/p/%E9%98%BF%E9%87%8C%E4%BA%91%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E6%8A%A2%E5%8D%A0%E5%AE%9E%E4%BE%8B/","title":"阿里云自动创建抢占实例"},{"content":"日本电力行业网络安全洞察 日本电力市场与监管机构介绍 电力市场介绍 1. 历史背景 1951年：日本成立了10家区域性电力公司，这些公司各自负责特定地区的发电、输电、配电和售电，形成了垂直一体化的垄断结构。 1995年：日本修订了《电力事业法》，允许独立发电企业（Independent Power Producers, IPPs）进入市场，标志着电力市场改革的开始。 1999年：逐步放开售电市场，允许特定规模电力事业者（Particular Purpose Suppliers, PPSs）向大中型用户售电。 2016年4月：全面放开电力零售市场，所有用户都可以自由选择电力供应商。 2. 市场结构 主要参与者： 10大区域性电力公司：北海道电力、东北电力、东京电力、北陆电力、中部电力、关西电力、中国电力、四国电力、九州电力、冲绳电力。 独立发电企业（IPPs）：这些企业主要提供火力发电、水力发电、核能发电和可再生能源发电。 特定规模电力事业者（PPSs）：这些企业向大中型用户提供电力服务。 电力零售商：向终端用户销售电力，包括居民用户和商业用户。 批发市场： 日本电力批发交易所（JEPX）：成立于2003年11月，2005年4月正式运营，提供现货交易和长期合同交易，旨在促进电力批发市场的透明度和效率。 3. 发电结构 \u0026ndash; TODO 检查准确性 火电：65% 核电：17% 水电：17% 可再生能源： 4. 结构规划 2030年能源构成草案： 日本经济产业省在2030年最佳能源构成草案中确定了将光伏发电比例控制在约7%的方针。这一目标是在22%至24%的可再生能源比例中的一部分。 日本政府鼓励可再生能源的开发和利用，许多电力公司都在积极投资风能、太阳能等可再生能源项目。 监管机构介绍 经济产业省（METI）： 电力市场科：负责电力市场的整体监管，包括电价、环境保护和发展规划。 资源能源厅：具体执行电力市场的监管工作，确保市场公平竞争和消费者权益。 日本电力系统利用协会（ESCJ）： 成立于2004年2月，是一个中立的民间机构，负责制定输配电规则并监督其执行，确保输配电系统的公平和透明。 电力批发交易所（JEPX）： 成立于2003年11月，2005年4月开始运营，是一个非营利性质的会员制机构，负责电力批发市场的交易和监管。 电力燃气交易监督委员会： 负责监督电力和燃气市场的交易，确保市场公平竞争，防止垄断和不公平行为。 中央电力委员会： 成立于1958年，负责协调各大电力公司和电源开发公司之间的关系，确保电力系统的稳定运行。 日本电气事业联合会（EEPC）： 负责行业管理和统计，协调各电力公司之间的合作和交流。 主要电力运营商介绍 北海道电力公司（HOKKAIDO ELECTRIC POWER CO., INC.） 总部：札幌 服务区域：北海道 成立时间：1951年 主要业务：发电、输电、配电、售电 东北电力公司（TOHOKU ELECTRIC POWER CO., INC.） 总部：仙台 服务区域：青森县、岩手县、宫城县、秋田县、山形县、福岛县、新泻县 成立时间：1951年 主要业务：发电、输电、配电、售电 东京电力公司（TOKYO ELECTRIC POWER COMPANY, INC.，简称TEPCO） 总部：东京 服务区域：东京都、埼玉县、千叶县、茨城县、群马县、栃木县、山梨县、静冈县东部 成立时间：1951年 主要业务：发电、输电、配电、售电、核电站运营 特点：日本最大的电力公司之一，因2011年福岛核事故而备受关注 北陆电力公司（HOKURIKU ELECTRIC POWER CO., INC.） 总部：金泽 服务区域：福井县、石川县、富山县 成立时间：1951年 主要业务：发电、输电、配电、售电 中部电力公司（CHUBU ELECTRIC POWER CO., INC.） 总部：名古屋 服务区域：长野县、岐阜县（部分）、爱知县、三重县（部分）、静冈县（部分） 成立时间：1951年 主要业务：发电、输电、配电、售电 关西电力公司（KANSAI ELECTRIC POWER CO., INC.） 总部：大阪 服务区域：京都府、大阪府、兵库县、滋贺县、奈良县、和歌山县、三重县（部分） 成立时间：1951年 主要业务：发电、输电、配电、售电 中国电力公司（CHUGOKU ELECTRIC POWER CO., INC.） 总部：广岛 服务区域：鸟取县、岛根县、冈山县、广岛县、山口县 成立时间：1951年 主要业务：发电、输电、配电、售电 四国电力公司（SHIKOKU ELECTRIC POWER CO., INC.） 总部：松山 服务区域：爱媛县、高知县、德岛县、香川县 成立时间：1951年 主要业务：发电、输电、配电、售电 九州电力公司（KYUSHU ELECTRIC POWER CO., INC.） 总部：福冈 服务区域：福冈县、佐贺县、长崎县、熊本县、大分县、宫崎县、鹿儿岛县 成立时间：1951年 主要业务：发电、输电、配电、售电 冲绳电力公司（OKINAWA ELECTRIC POWER CO., INC.） 总部：那霸 服务区域：冲绳县 成立时间：1951年 主要业务：发电、输电、配电、售电 光伏行业准入门槛与适用监管要求介绍 主要光伏产业运营商介绍 1. 京瓷株式会社（Kyocera Corporation） 官网 公司简介： 京瓷是一家全球知名的电子和陶瓷产品制造商，也是日本最大的光伏组件生产商之一。 光伏业务： 京瓷在光伏领域拥有丰富的经验和强大的技术实力，生产高质量的太阳能电池板和系统。公司还积极参与大型光伏电站的建设和运营。 主要项目： 2012年，京瓷设立了“鹿儿岛百万瓦级太阳能发电公司”，运营日本最大的光伏电站——“鹿儿岛七岛百万瓦级太阳能发电站”，发电能力为70兆瓦（7万千瓦）。 2. 夏普株式会社（Sharp Corporation）官网 公司简介： 夏普是一家全球领先的电子和家电制造商，也在光伏领域有着广泛的技术积累和市场影响力。 光伏业务： 夏普生产各种类型的太阳能电池板和系统，包括高效单晶硅和多晶硅电池板。公司还涉足光伏系统的安装和维护服务。 3. 东芝能源系统与解决方案公司（Toshiba Energy Systems \u0026amp; Solutions Corporation） 官网 公司简介： 东芝能源系统与解决方案公司是东芝集团的子公司，专注于能源解决方案和基础设施建设。 光伏业务： 公司提供从太阳能电池板生产到光伏系统集成的全方位服务，参与多个大型光伏电站项目。 4. TMEIC（Toshiba Mitsubishi-Electric Industrial Systems Corporation） 公司简介： TMEIC是由东芝和三菱电机各出资50%成立的合资公司，专注于工业自动化和能源解决方案。 光伏业务： TMEIC在光伏逆变器领域表现突出，是日本唯一一家2020年光伏逆变出货量全球排名进入10强的公司。公司还提供光伏系统的集成和运维服务。 5. Panasonic Holdings Corporation 公司简介： Panasonic是一家全球知名的电子和家电制造商，也在光伏领域有着深厚的技术积累。 光伏业务： Panasonic生产高效的太阳能电池板和系统，提供从设计到安装的全套解决方案。公司还参与了多个大型光伏项目的建设和运营。 6. Sonnedix Japan 公司简介： Sonnedix是一家独立的太阳能生产商，专注于光伏电站的开发、建设和运营。 光伏业务： Sonnedix在日本运营多个大型光伏电站，其中包括位于岩手县的32.9MW Iwate Miyako光伏电站。该电站年发电量达39000MWh，可为1.32万户日本家庭供电。 海外光伏市场贸易限制趋势 日本光伏产品准入要求 认证与标准 J-PEC认证： 日本太阳能发电普及扩大中心（J-PEC）认证是进入日本住宅用屋顶太阳能发电市场（\u0026lt;10kW）的必要条件。只有获得J-PEC认证的产品才能享受政府的补贴。 JET认证： 日本电气安全环境测试实验室（JET）认证主要针对大型屋顶和地面电站项目。JET认证确保产品符合日本的安全和性能标准。 PSE认证 ：所有进入日本市场的电气产品需要由日本经济产业省（METI）进行PSE认证，主要分两类： A类： 必须获得经日本政府授权的符合性评估机构颁发的“符合性证书”（CoC）。 B类： 无须获得CoC，但必须符合法令规定的安全标准，并在产品上贴上PSE标志。 固定价格收购制度（FIT） FIT制度： 日本从2012年开始实施固定的上网电价（FIT）制度，规定电力公司必须以固定价格收购可再生能源产生的电力。虽然这一制度鼓励了光伏产业的发展，但也对项目的规模和类型有一定的限制。 逐步调整FIT价格： 为了控制财政负担，日本政府逐步降低了FIT价格。例如，2013年大型电站的补贴从42日元/千瓦时降至37.8日元/千瓦时。 市场准入壁垒 高技术标准： 日本对光伏产品的技术和安全标准要求较高，这使得一些外国产品难以进入市场。例如，光伏支架需要符合日本建筑设计规范JISC8955，这比欧洲和美国的标准更为严格。 民族情结和质量意识： 日本消费者普遍倾向于选择国产产品，对外来产品有一定的抵触情绪。这增加了外国企业在市场推广中的难度。 日本光伏产品合规要求 JIS标准（Japanese Industrial Standards） JIS C 8911：光伏组件的性能和安全标准。 JIS C 8912：光伏逆变器的性能和安全标准。 JIS C 8914：光伏系统的安装和维护标准。 JIS C 8915：光伏系统的性能测试方法。 IEC标准（International Electrotechnical Commission） IEC 61215：晶体硅光伏组件的性能和安全标准。 IEC 61730：光伏组件的安全认证标准。 IEC 62109：光伏逆变器的安全标准。 IEC 62446：光伏系统的安装和维护标准。 J-PEC标准 概述：由日本太阳能发电普及扩大中心（J-PEC）制定的标准，主要适用于小型住宅用屋顶太阳能发电系统。 相关标准：确保光伏产品符合日本市场的安全和性能标准，获得J-PEC认证的产品才能享受政府的补贴。 JET认证标准 概述：由日本电气安全环境测试实验室（JET）制定的标准，主要适用于大型屋顶和地面电站项目。 相关标准：确保光伏产品符合日本的安全和性能标准，包括电气安全、机械强度和环境耐受性等。 PSE认证标准 概述：由日本经济产业省（METI）制定的标准，所有进入日本市场的电气产品必须符合PSE认证标准。 相关标准：PSE认证分为A类和B类，分别有不同的认证要求。 其他重要标准 ISO 9001：质量管理体系标准，企业应建立并维护符合ISO 9001标准的质量管理体系，确保产品的质量和一致性。 ISO 14001：环境管理体系标准，企业应建立并维护符合ISO 14001标准的环境管理体系，确保产品的环保性能。 日本通用网络安全监管要求介绍 网络安全监管机构 1. 内阁网络安全中心（NISC） 全称： National Center of Incident Readiness and Strategy for Cybersecurity (NISC) 成立时间： 2015年 职责： 制定和实施国家网络安全战略。 协调各政府部门和私营部门的网络安全工作。 监测和应对重大网络安全事件。 提供网络安全培训和技术支持。 与国际组织合作，分享网络安全信息和最佳实践。 2. 信息处理推进机构（IPA） 全称： Information-technology Promotion Agency, Japan (IPA) 成立时间： 1967年 职责： 开展网络安全研究和技术开发。 提供网络安全咨询服务和技术支持。 发布网络安全指南和最佳实践。 组织网络安全培训和演练。 运营日本计算机应急响应团队（JPCERT/CC）。 3. 国家警察厅（NPA） 全称： National Police Agency (NPA) 成立时间： 1945年 职责： 打击网络犯罪，包括网络诈骗、黑客攻击等。 协调地方警察的网络安全工作。 与国际执法机构合作，打击跨国网络犯罪。 4. 通信安全研究所（NICT） 全称： National Institute of Information and Communications Technology (NICT) 成立时间： 2004年 职责： 开展网络安全研究和技术开发。 提供网络安全技术支持和咨询服务。 运营日本网络安全应急响应团队（JPCERT/CC）。 参与国际网络安全合作和信息共享。 5. 金融厅（FSA） 全称： Financial Services Agency (FSA) 成立时间： 2000年 职责： 监管金融机构的网络安全。 制定和实施金融领域的网络安全政策。 提供网络安全指导和支持。 与金融机构合作，应对网络安全事件。 6. 东京警视厅网络安全对策总部 成立时间： 2016年 职责： 打击网络犯罪，特别是针对东京地区的网络犯罪。 协调地方警察的网络安全工作。 与国际执法机构合作，打击跨国网络犯罪。 7. 经济产业省（METI） 全称: Ministry of Economy, Trade and Industry (METI) 成立时间： 2001年 职责： 制定和实施工业和信息技术领域的网络安全政策。 促进企业和产业界的网络安全意识和技术提升。 协调相关机构的网络安全工作。 8. 总务省（MIC） 全称： Ministry of Internal Affairs and Communications (MIC) 成立时间： 2001年 职责： 制定和实施通信和信息领域的网络安全政策。 监管电信运营商的网络安全。 促进网络安全技术的研发和应用。 通用网络安全标准 法规 《网络安全基本法》（Cybersecurity Basic Act） 颁布时间 ：2014年11月 主要内容 ： 设立内阁网络安全中心（NISC），负责制定和实施国家网络安全战略。 强化政府与民间在网络安全领域的协调和合作。 规定电力、金融等重要社会基础设施运营商、网络相关企业、地方自治体等有义务配合网络安全相关举措或提供相关情报。 《个人信息保护法》（Act on the Protection of Personal Information） 颁布时间 ：2003年，2015年修订 主要内容 ： 保护个人隐私，防止个人信息的不当收集、使用和泄露。 规定企业和组织在处理个人信息时的义务和责任。 设立个人信息保护委员会（Personal Information Protection Commission），负责监督和执法。 《反垃圾邮件法》（Act on Regulation of Sending Specified Electronic Mail） 颁布时间 ：2008年 主要内容 ： 规范电子邮件的发送行为，防止垃圾邮件的传播。 对发送垃圾邮件的行为进行处罚。 《禁止非法读取信息法》（Act on Prohibition of Unauthorized Access to Computerized Data） 颁布时间 ：1999年 主要内容 ： 禁止未经授权访问计算机系统和数据。 对非法入侵行为进行处罚。 《电子契约法》（Act on Electronic Signatures and Certification Services） 颁布时间 ：2000年 主要内容: 规范电子签名和认证服务，确保电子交易的安全性和可靠性。 促进电子商务的发展。 标准 JIS标准（Japanese Industrial Standards） JIS Q 27001： 信息安全管理体系（ISMS）标准，对应国际标准ISO/IEC 27001。 JIS X 0151： 信息技术——开放系统互连——安全体系结构，对应国际标准ISO/IEC 7498-2。 JIS X 0152： 信息技术——安全技术——信息安全评估标准，对应国际标准ISO/IEC 15408。 ISO/IEC标准 ISO/IEC 27001： 信息安全管理体系（ISMS）标准，提供了一套规范和要求，帮助企业建立和维护信息安全管理体系。 ISO/IEC 27002： 信息安全控制实践指南，提供了具体的信息安全控制措施和建议。 ISO/IEC 27017： 云服务信息安全控制指南，针对云服务提供商和用户的信息安全控制措施。 ISO/IEC 27018： 公有云中个人身份信息（PII）处理者行为准则，提供了处理个人身份信息的指南。 NIST标准（National Institute of Standards and Technology） NIST SP 800-53： 安全控制标准，提供了联邦信息系统和组织的安全控制措施。 NIST SP 800-37： 风险管理框架，提供了管理和评估信息安全风险的方法和流程。 JPCERT/CC指南 日本计算机应急响应团队（JPCERT/CC） 发布的各种网络安全指南和最佳实践，帮助企业提高网络安全水平。 IPA指南 信息处理推进机构（IPA） 发布的网络安全指南和技术文档，涵盖了多个领域的网络安全实践 电力行业网络安全标准 《电气通信事业法》（Telecommunications Business Law） 修订时间 ：2019年 主要内容 ： 加强对物联网设备的信息安全要求，要求设备制造商采取必要的安全措施，防止设备被用于网络攻击。 规定电信运营商有责任确保其网络和系统的安全性。 ","date":"2024-11-08T14:33:55+08:00","permalink":"https://blog-g.leecq.cn/p/%E6%97%A5%E6%9C%AC%E7%94%B5%E5%8A%9B%E8%A1%8C%E4%B8%9A%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%B4%9E%E5%AF%9F/","title":"日本电力行业网络安全洞察"},{"content":"安装 官方下载页面 一键命令：curl -o 'Nessus-10.8.2-ubuntu1604_amd64.deb' 'https://www.tenable.com/downloads/api/v2/pages/nessus/files/Nessus-10.8.2-ubuntu1604_amd64.deb' \u0026amp;\u0026amp; sudo apt install ./Nessus-10.8.2-ubuntu1604_amd64.deb\nWindows破解版\n启动 Windows 版本 ","date":"2024-09-10T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/nessus-%E6%BC%8F%E6%B4%9E%E6%89%AB%E6%8F%8F/","title":"Nessus - 漏洞扫描"},{"content":"systemd 是一个系统和服务管理器，它是许多现代Linux发行版（如Fedora、Red Hat Enterprise Linux、Debian、Ubuntu等）中默认使用的初始化系统。systemd 提供了一种替代传统的SysV init系统的方法，旨在提高系统的启动速度和运行效率，并且提供了更为强大的服务管理和依赖关系处理机制。\nsystemd的特点 并发启动：systemd 支持并行启动服务，这意味着它可以在同一时间启动多个服务，而不是像传统init系统那样顺序启动。 依赖关系管理：它可以自动处理服务之间的依赖关系，确保当一个服务启动时，其依赖的服务也已经启动。 Socket激活：允许服务监听套接字，当有连接请求到达时自动启动服务。 设备挂载和挂载点激活：systemd 可以基于设备挂载状态来控制服务的启动。 统一的日志记录：通过journald，systemd 统一了系统日志记录方式，并且提供了比传统syslog更丰富的查询和过滤功能。 资源控制：可以对服务的资源使用（如CPU和内存）进行限制。 服务单元文件：systemd 使用.service、.socket、.timer等单元文件来描述服务、套接字和定时任务等。\n基本命令 一些常用的systemd命令包括：\nsystemctl list-unit-files：列出所有已知的单元文件。 systemctl start \u0026lt;service\u0026gt;：启动指定的服务。 systemctl stop \u0026lt;service\u0026gt;：停止指定的服务。 systemctl restart \u0026lt;service\u0026gt;：重启指定的服务。 systemctl status \u0026lt;service\u0026gt;：查看指定服务的状态。 systemctl enable \u0026lt;service\u0026gt;：使服务开机自启。 systemctl disable \u0026lt;service\u0026gt;：禁止服务开机自启。 systemctl daemon-reload：重新加载systemd配置。 journalctl：查看系统日志。 单元文件示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [Unit] Description=The Nginx HTTP Server After=network.target [Service] User=nginx group=nginx ExecStart=/usr/sbin/nginx Restart=always RestartSec=10s Type=forking PIDFile=/run/nginx.pid [Install] WantedBy=multi-user.target ","date":"2024-09-09T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/linux%E7%B3%BB%E7%BB%9F%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%99%A8/","title":"Linux系统守护进程管理器"},{"content":"nmap（Network Mapper）是一个开源的网络探测和安全审核工具，可以用来扫描网络中的主机和服务，发现它们的端口开放情况、使用的协议、操作系统类型等信息。\n安装 Ubuntu \u0026amp; Debian :sudo apt update \u0026amp;\u0026amp; sudo apt install nmap CentOS \u0026amp; RHEL : sudo yum install nmap\n常用参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 -p 指定端口，\u0026#34;,\u0026#34;分割，\u0026#34;2-100\u0026#34;指定一个范围，\u0026#34;-\u0026#34;指定全部端口 -v 输出详细信息 -sP：执行Ping扫描，用于快速发现网络中的活动主机。 -sT：执行TCP连接扫描，默认的扫描方式。 -sS：执行TCP SYN扫描（半开扫描），发送SYN包而不建立完整的三次握手。 -sU：执行UDP扫描，探测开放的UDP端口。 -sA：执行ACK扫描，用于确定防火墙规则集。 -sW：执行Window扫描，用于探测防火墙规则集。 -sM：执行IP协议扫描，用于探测IP协议 -A：执行详细的扫描，包括操作系统检测、版本检测、脚本扫描和服务识别。 -T：设置扫描速度，取值范围从T0（最慢）到T5（最快）。 -O：执行操作系统检测。 -sV：执行服务版本检测。 -oN：将扫描结果输出到普通文本文件。 -oX：将扫描结果输出到XML文件。 -oG：将扫描结果输出到Grep格式文件。 --script：执行指定的脚本。 --script-help：显示脚本的帮助信息。 -D：指定欺骗源地址（IP欺骗） -e：指定扫描时使用的接口。 -n：不执行DNS反向解析。 -R：强制执行DNS反向解析。 -Pn：假设目标主机是在线的，即使没有回应。 --max-retries：设置最大重试次数。 --host-timeout：设置主机超时时间。 使用 扫描指定机器的全部端口: nmap -p- -v -A \u0026lt;host\u0026gt; 扫描一个IP地址段: nmap 192.168.1.1-255 ","date":"2024-09-09T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/nmap-%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E5%99%A8/","title":"nmap - 网络扫描器"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 \u0026#34;\u0026#34;\u0026#34; 通过监听快捷键快速实现指定功能。 监听快捷键 [Alt + O], 从剪切板拿到图片数据，通过调用腾讯AI的OCR接口，获得返回后的文本，将OCR的文本放入剪切板中。 Python Version: 3.12.2 依赖： win10toast==0.9 -- 向操作系统发送通知 pywin32==223 -- Windons API 库 Pillow==10.4.0 -- PIL 图像处理库 keyboard==0.13.5 -- 使用这个小型Python库完全控制你的键盘。挂钩全局事件、注册热键、模拟按键等等。 requests==2.32.3 -- HTTP请求库 快速安装： pip install win10toast==0.9 pywin32==223 Pillow==10.4.0 keyboard==0.13.5 requests==2.32.3 \u0026#34;\u0026#34;\u0026#34; import base64 import datetime import io import json import logging import random import hashlib import hmac import time import functools from pathlib import Path from urllib.parse import urlparse import requests import keyboard import pyperclip import win32clipboard as wc from PIL import Image from win10toast import ToastNotifier logger = logging.getLogger(\u0026#34;root\u0026#34;) FILE_DIR = Path(__file__).parent.absolute() keys = json.loads(FILE_DIR.joinpath(\u0026#34;self_config.json\u0026#34;).read_text()) s_keys = keys[\u0026#34;tencent_key\u0026#34;] def send_notication(title, text, duration=3): ToastNotifier().show_toast(title=title, msg=text, duration=duration, threaded=True) def get_image_from_clipboard(): try: wc.OpenClipboard() if wc.IsClipboardFormatAvailable(wc.CF_DIB): # Get the device-independent bitmap (DIB) format data dib = wc.GetClipboardData(wc.CF_DIB) return Image.open(io.BytesIO(dib)) except Exception as e: logger.error(f\u0026#34;Error reading image from clipboard: {e}\u0026#34;) return 0 finally: wc.CloseClipboard() def most_english(text) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34;字符串中大多数是英语\u0026#34;\u0026#34;\u0026#34; if len(text) == 0: raise ValueError(\u0026#34;空字符串.\u0026#34;) ec_num = 0 for c in text: if c.isalpha and \u0026#34;a\u0026#34; \u0026lt;= c.lower() \u0026lt;= \u0026#34;z\u0026#34;: ec_num += 1 if ec_num / len(text) \u0026gt; 0.5: return True return False @functools.lru_cache(25) def translate_api(text, from_lang=\u0026#34;auto\u0026#34;, to_lang=\u0026#34;zh\u0026#34;) -\u0026gt; list[dict[str, str]]: \u0026#34;\u0026#34;\u0026#34;翻译API， return src, dst \u0026#34;\u0026#34;\u0026#34; url = \u0026#34;http://api.fanyi.baidu.com/api/trans/vip/translate\u0026#34; salt = random.randint(32768, 65536) appid, appkey = keys[\u0026#34;baidu_translate\u0026#34;] sign = hashlib.md5((appid + text + str(salt) + appkey).encode(\u0026#34;utf-8\u0026#34;)).hexdigest() resp = requests.post( url=url, headers={\u0026#34;Content-Type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34;}, params={ \u0026#34;appid\u0026#34;: appid, \u0026#34;q\u0026#34;: text, \u0026#34;from\u0026#34;: from_lang, \u0026#34;to\u0026#34;: to_lang, \u0026#34;salt\u0026#34;: salt, \u0026#34;sign\u0026#34;: sign, }, ) if resp.status_code != 200: raise Exception(resp.text()) return resp.json().get(\u0026#34;trans_result\u0026#34;) def translate_iamge(image_data: bytes, from_lang=\u0026#34;auto\u0026#34;, to_lang=\u0026#34;zh\u0026#34;) -\u0026gt; list: \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; url = \u0026#34;http://fanyi-api.baidu.com/api/trans/sdk/picture\u0026#34; salt = random.randint(32768, 65536) appid = \u0026#34;20240531002066479\u0026#34; appkey = \u0026#34;05IgcgzWKnf5J7hDKlyK\u0026#34; file_md5 = hashlib.md5(image_data).hexdigest() cuid, mac = \u0026#34;APICUID\u0026#34;, \u0026#34;mac\u0026#34; sign = hashlib.md5( (appid + file_md5 + str(salt) + cuid + mac + appkey).encode() ).hexdigest() payload = { \u0026#34;from\u0026#34;: from_lang, \u0026#34;to\u0026#34;: to_lang, \u0026#34;appid\u0026#34;: appid, \u0026#34;salt\u0026#34;: salt, \u0026#34;sign\u0026#34;: sign, \u0026#34;cuid\u0026#34;: cuid, \u0026#34;mac\u0026#34;: mac, } image = {\u0026#34;image\u0026#34;: (\u0026#34;translate-iamge\u0026#34;, image_data, \u0026#34;multipart/form-data\u0026#34;)} resp = requests.post(url, params=payload, files=image) if resp.status_code != 200: raise Exception(resp.text()) return resp.json().get(\u0026#34;data\u0026#34;, {}).get(\u0026#34;content\u0026#34;, []) def translate(): # 从剪贴板读取数据 keyboard.send(\u0026#34;ctrl+c\u0026#34;) clipb_data = pyperclip.paste() if not clipb_data: logger.error(\u0026#34;翻译失败: 未从剪切板获取到数据\u0026#34;) send_notication(\u0026#34;翻译失败\u0026#34;, \u0026#34;未从剪切板获取到数据\u0026#34;) return logger.debug(\u0026#34;剪贴板内容: %s\u0026#34;, clipb_data) # 处理剪贴板数据 processed_data = translate_api( clipb_data, to_lang=\u0026#34;zh\u0026#34; if most_english(clipb_data) else \u0026#34;en\u0026#34;, ) # processed_data = json.dumps(processed_data, ensure_ascii=False, indent=2) processed_data = \u0026#34;\\n\u0026#34;.join([l.get(\u0026#34;dst\u0026#34;) for l in processed_data]) # 将处理后的数据放回剪贴板 pyperclip.copy(processed_data) # keyboard.send(\u0026#34;F3\u0026#34;) send_notication(\u0026#34;翻译结果已经放入剪切板\u0026#34;, processed_data) logger.debug(\u0026#34;处理后的数据已放回剪贴板: %s\u0026#34;, processed_data) if __name__ == \u0026#34;__main__\u0026#34;: # 注册快捷键组合 keyboard.add_hotkey(\u0026#34;ctrl+alt+d\u0026#34;, translate, suppress=False) print(\u0026#34;\u0026#34;\u0026#34;1. 监听快捷 [Ctrl+Alt+S], 从剪切板中得到拿到文本数据, 通过调用百度翻译的API接口翻译文本，将翻译后的数据放入剪切板中。 2. 监听快捷键 [Alt + O], 从剪切板拿到图片数据，通过调用腾讯AI的OCR接口，获得返回后的文本，将OCR的文本放入剪切板中。\u0026#34;\u0026#34;\u0026#34;) logging.basicConfig(level=\u0026#34;DEBUG\u0026#34;) # 保持程序运行，直到手动终止 keyboard.wait() ","date":"2024-08-17T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/%E5%BF%AB%E6%8D%B7%E7%BF%BB%E8%AF%91%E8%84%9A%E6%9C%AC/","title":"快捷翻译脚本"},{"content":"Kubernetes初期为存算分离所做的解耦设计Volume，采用强耦合、灵活性差的in-tree模式，虽然已经让用户专注于业务功能设计。但这类存储卷的生命周期是跟随pod的，只能用作存储临时数据，无法做为最终数据使用。\n随着Kubernetes的不断成熟，为支持更多的应用场景，提供了一种脱离pod生命周期的、用户可管理的存储抽象设计低耦合、灵活性更强的PersistentVolume/PersistentVolumeClaim。\n常用卷类型 Kubernetes支持的卷可分为以下几类：\n临时存储：\nEmptyDir：emptyDir生命周期和POD保持一致，pod删除后，emptyDir中的数据也会被清除。 HostPath：将节点本地文件系统的路径映射到pod容器中。pod删除后，HostPath中的数据是否清除，依赖于用户的pod配置。 In-tree的网络存储：网络存储跟随pod的生命周期，通过in-tree的存储插件对接不同类型存储。 持久存储声明\nPersistentVolumeClaim：存储具有独立的生命周期，可以通过存储提供商提供的out-tree插件，对接其存储。 配置数据\nConfigMap/Secret：存储少量配置或敏感数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 spec: volumes: # 存储卷有多种类型，以下为一些常用类型 - name: string # 存储卷名称 emptyDir: {} # 临时生成的一个目录，与pod生命周期同步 - name: string hostPath: # 挂载宿主机的目录 path: string # 用于挂载的目录 - name: string nfs: server: string # 服务IP地址 path: string # 用于挂载的目录 - name: string persistentVolumeClaim: # 调用已经创建的持久卷 claimName: string # 持久卷声明的名称 - name: string configMap/secret: # 挂载ConfigMap或Secret到容器内 name: string # ConfigMap或Secret的名称 items: # 要调用的键，值会被写入文件,可以设定多个 - key: string path: string # 文件名 持久化存储体系介绍 k8s持久化存储体系包括：\nPersistentVolume：简称PV，持久化存储，是Kubernetes为云原生应用提供一种拥有独立生命周期的、用户可管理的存储抽象设计。 PersistentVolumeClaim：简称PVC，持久化存储声明，是Kubernetes为解耦云原生应用和数据存储而设计的，通过PVC可以让资源管控更细更灵活、团队职责分离、应用模板更通用，进一步解除了用户被云平台锁定的顾虑。 StorageClass：简称SC，存储类，是Kubernetes平台为存储提供商提供存储接入的一种声明，通过SC和相应的存储插件（CSI）为容器应用提供动态分配存储卷的能力。 Driver Plugin：存储驱驱动插件，由存储提供商提供，能够对接网络存储，并管理持久存储卷的生命周期。 静态卷(Static Volumes) \u0026amp; 动态卷(Dynamic Volumes) 静态卷是在 Kubernetes 集群中预先创建好的 Persistent Volumes (PVs)。这些 PVs 通常由集群管理员手动创建，并配置好所有必要的参数，如存储后端、访问模式、存储大小等。静态卷不依赖于任何特定的 StorageClass。\n静态卷 - 特点: 手动创建: 静态卷由管理员手动创建，并且在创建时就指定了所有必要的参数。 不依赖 StorageClass: 静态卷不依赖于 StorageClass，因此不会自动创建或销毁。 固定资源: 一旦创建，静态卷就存在于集群中，直到被明确回收或删除。 手动管理: 静态卷需要手动管理，包括创建、分配和回收 静态卷 - 适用场景 当需要特定的存储后端或存储配置时。 当存储资源有限且需要精细控制时。 当需要使用特定的存储后端，而该后端不支持动态配置时。 动态卷是由 StorageClass 自动创建的 Persistent Volumes (PVs)。当用户通过 Persistent Volume Claim (PVC) 请求存储资源时，动态卷会根据 PVC 中指定的 StorageClass 自动创建和配置 PV。\n动态卷 - 特点 自动创建: 动态卷是在 PVC 被创建时自动创建的，由 StorageClass 配置。 依赖 StorageClass: 动态卷依赖于 StorageClass，后者定义了如何创建 PVs。 按需供应: 用户只需指定所需存储资源的大小和访问模式，PVs 将根据需要自动创建。 自动回收: 动态卷可以根据 StorageClass 中的配置自动回收。 动态卷 - 适用场景 当需要快速创建和销毁存储资源时。 当存储资源充足且不需要精细控制时。 当使用支持动态配置的存储后端时，如云提供商的存储服务。 PV / PVC - 绑定原理 PVC刷选PV的流程（findBestMatchForClaim）：\n通过size刷选恰当的PV； 通过volumeMode刷选一致的PV； 通过Label刷选合适的PV； 通过SC刷选符合的PV； 通过AccessMode刷选符合条件的PV； 返回并绑定符合PVC条件，且size最小的PV。 PersistentVolume - 使用PV PV中定义应用所需的规格等配置：\naccessModes： ReadWriteOnce：读写权限，并且只能被单个Node挂载，如：云盘。 ReadOnlyMany：只读权限，允许被多个Node挂载，如：文件存储。 ReadWriteMany：读写权限，允许被多个Node挂载，如：文件存储。 capacity.storage：容量大小 csi：out-tree驱动配置信息。 persistentVolumeReclaimPolicy： Retain - 保留 Recycle - 回收空间 Delete：删除 storageClassName：storageClass的名称。 volumeMode： Filesystem：将云盘挂载为文件系统。 Block：将云盘挂载为块设备。 PV声明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 appVersion: v1 kind: PersistentVolume metadata: name: static-volume spce: accessModes: # 有多种访问模式，供PVC选择 - ReadWriteOnce capacity: storage: 10Gi csi: driver: dick.csi.everest.io fsType: ext4 volumeAttributes: everest.io/disk-mode: SCSI everest.io/disk-volume-type: SAS storage.kubernetes.io/csiProvisionerIdentity: everest-csi-provisioner volumeHandle: 9a074a5b-a67e-4fae-860e-07c5307594ea persistentVolumeReclaimPolicy: Retain storageClassName: csi-disk volumeMode: Filesystem PersistentVolumeClaim - 使用PVC PVC中定义应用所需的规格等配置：\naccessModes： ReadWriteOnce ReadOnlyMany ReadWriteMany，与PV设置相同。 resources： Requests：资源请求，与PV设置相同。 volumeMode： Filesystem：将云盘挂载为文件系统，与PV设置相同。 Block：将云盘挂载为块设备，与PV设置相同。 volumeName/storageClassName：PV或者storageClass的名称。 selector：通过对Label Selector的设置，可使PVC对于系统中已存在的各种PV进行筛选。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 apiVersion: v1 kind: PersistentVolumeClaim metadata: annotations: everest.io/disk-volume-type: sas volume.beta.kubernetes.io/storage-provisioner: everest-csi-provisioner labels: app: mysql-adv-mgmd release: mysql-adv name: mysql-data-mysql-adv-mgmd-0 namespace: default spec: accessModes: - ReadWriteOnce resources: requests: storage: 10Gi volumeName/storageClassName: csi-disk volumeMode: Filesystem selector: matchLabels: release: \u0026#34;stable\u0026#34; StorageClass-使用SC SC中定义存储类型和驱动等配置：\nParameters：插件驱动定义的参数。 Provisioner：指定存储卷的供应者。 reclaimPolicy: Retain/Recycle/Delete：保留数据/回收空间/删除。 volumeBindingMode： Immediate：立即绑定。 WaitForFirstConsumer：延迟绑定。 allowVolumeExpansion： True：允许扩容。 False：不允许扩容。 定义SC：\n1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: csi-disk-ssd parameters: csi.storage.k8s.io/csi-driver-name: disk.csi.everest.io csi.storage.k8s.io/fstype: ext4 everest.io/disk-volume-type: SSD everest.io/passthrough: \u0026#34;true\u0026#34; provisioner: everest-csi-provisioner reclaimPolicy: Delete volumeBindingMode: Immediate allowVolumeExpansion: true 最佳实践 创建3个实例的MySQL服务： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 # 该Yaml中依次定义了所需要的全部文件。 # 1. 创建SC apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: csi-disk-ssd parameters: csi.storage.k8s.io/csi-driver-name: disk.csi.everest.io csi.storage.k8s.io/fstype: ext4 everest.io/disk-volume-type: SSD everest.io/passthrough: \u0026#34;true\u0026#34; provisioner: everest-csi-provisioner reclaimPolicy: Delete volumeBindingMode: Immediate allowVolumeExpansion: true --- # 2. 创建PVC - 0 apiVersion: v1 kind: PersistentVolumeClaim metadata: name: mysql-data-0 spec: accessModes: - ReadWriteOnce resources: requests: storage: 10Gi storageClassName: csi-disk-ssd --- # 2. 创建PVC - 1 apiVersion: v1 kind: PersistentVolumeClaim metadata: name: mysql-data-1 spec: accessModes: - ReadWriteOnce resources: requests: storage: 10Gi storageClassName: csi-disk-ssd --- # 2. 创建PVC - 2 apiVersion: v1 kind: PersistentVolumeClaim metadata: name: mysql-data-2 spec: accessModes: - ReadWriteOnce resources: requests: storage: 10Gi storageClassName: csi-disk-ssd --- # 3.创建ConfigMap定义MySQL配置文件 apiVersion: v1 kind: ConfigMap metadata: name: mysql-config data: my.cnf: | [mysqld] bind-address = 0.0.0.0 innodb_file_per_table = 1 character-set-server=utf8mb4 collation-server=utf8mb4_unicode_ci skip-name-resolve --- # 4. 创建 StatefulSet apiVersion: v1 kind: StatefulSet metadata: name: mysql spec: serviceName: mysql replicas: 3 seletor: matchLabels: app: mysql template: metadata: labels: app: mysql spec: containers: - name: mysql-adv image: mysql:5.7 env: - name: MYSQL_ROOT_PASSWORD valueFrom: secretKeyRef: name: secret_mysql key: root_password ports: - containerPort: 3306 volumeMounts: - name: mysql-data mountPath: /var/lib/mysql - name: mysql-config mountPath: /etc/mysql/conf.d volumes: - name: mysql-config configMap: name: mysql-config volumeClaimTemplates: - metadata: name: mysql-data annotations: everest.io/disk-volume-type:SATA spce: accessModes: [\u0026#34;ReadWriteOnce\u0026#34;] storageClassName: csi-disk-ssd volumeMode: FileSystem resources: requests: storage: 10Gi --- # 创建Service，提供访问接口 apiVersion: v1 Kind: Service metadata: name: mysql spec: selector: app: mysql ports: - port: 3306 containerPort: 3306 clusterIP: None # 使用 Headless Service 应用上述文件kubectl apply -f temp.yaml 将会创建3个有状态的MySQL实例，每个实例绑定一个PVC，拥有10Gi存储。 查看PVC kubectl get pvc 查看PV kubectl get pv ","date":"2024-08-06T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kubernetes%E7%9A%84%E5%AD%98%E5%82%A8/","title":"Kubernetes的存储"},{"content":"Service是实现基于4层TCP或UDP的流量转发与负载均衡，而Ingress可以通过七层的HTTP和HTTPS协议进行请求转发，可以通过域名和路径做到更细粒度的流量划分与转发。\nIngress和Ingress controller Ingress是Kubernetes中的一种资源对象，用来管理集群外部访问集群内部服务的方式；\n可以通过Ingress资源来配置不同的转发规则，从而达到根据不同的规则设置访问集群内不同的Service所对应的后端Pod；\nIngress通过http或https暴露集群内部service，给service提供外部URL、负载均衡、SSL/TLS能力以及基于host的反向代理。\nIngress-controller是具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现转发；\nIngress-controller并不是Kubernetes自带的组件，用户可以选择不同的ingress-controller实现，比如Kubernetes官方维护的NGINXIngressController，不同厂商通常有自己的实现，例如华为云CCE使用华为云弹性负载均衡服务ELB实现Ingress的七层负载均衡。\nIngress Controller的工作原理 当用户创建活更新Ingress资源后，Ingress Controller就会根据其中定义的转发规则刷新LoadBalancer配置文件（如：nginx.conf，或者华为云ELB配置）中。在外部流量访问集群时，由LoadBalancer组件跟据转发规则将其转发至对应的各个工作负载。\nIngress 配置文件示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: minimal-ingress annotations: # 即注解内容，该内容用于配置一些选项，具体取决于Ingress Controller，不同的Ingress Controller支持不同的注解. nginx.ingress.kubernetes.io/rewrite-target: / spec: rules: - http: paths: - path: /testpath # host: foo.service.com 可选：该规则适用于通过指定IP地址的所有入站HTTP通信。如果提供了host（例如foo.bar.com），则rules适用于该host。 pathType: prefix backend: service: name: test port: number: 80 解析： Metadata.annotations： 即注解内容，该内容用于配置一些选项，具体取决于Ingress Controller，不同的Ingress Controller支持不同的注解，如以下示例即华为云CCE使用华为云弹性负载均衡服务ELB实现Ingress的注解内容，其中指定了“ingress.class”信息，ELB的IP、端口等信息。\n1 2 3 4 5 6 7 metadata: name: test-ingress annotations: # 指定使用的ELB实例的信息 kubernetes.io/ingress.class: cce kubernetes.io/elb.port: \u0026#39;8080\u0026#39; kubernetes.io/elb.ip: 192.168.10.155 kubernetes.io/elb.id: aa7cf5ec-7218-4c43-98d4-c36c0744667a spec.rules 参数即转发规则，每个HTTP规则都包含以下信息：\nhost（可选）：在此示例中，未指定host，因此该规则适用于通过指定IP地址的所有入站HTTP通信。如果提供了host（例如foo.bar.com），则rules适用于该host。\npaths（路径列表，例如，/testpath）：每个路径都有一个由serviceName和servicePort定义的关联后端。在负载均衡器将流量定向到引用的服务之前，主机和路径都必须匹配传入请求的内容。\nPathType（路径类型）：未明确设置pathType的路径无法通过合法性检查，当前支持三种路径类型：\nExact：精确匹配URL路径，且区分大小写 Prefix：基于以“/”分隔的URL路径前缀匹配，匹配区分大小写，并且对路径中的元素逐个完成。 ImplementationSpecific 后端（backend）是Service文档中所述的服务和端口名称的组合。与规则的host和path匹配的对Ingress的HTTP（和HTTPS）请求将发送到列出的backend。\n如Ingress同时路由到多个服务，配置如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 spec: rules: - host: foo.bar.com # host地址 http: paths: - path: \u0026#34;/foo\u0026#34; #当访问“http://foo.bar.com/foo”时，即访问到“s1:80”后端 backend: serviceName: s1 servicePort: 80 - path: \u0026#34;/bar\u0026#34; #当访问“http://foo.bar.com/bar”时，即访问到“s2:80”后端 backend: serviceName: s2 servicePort: 80 Service 和 Ingress的对比 DNS 策略对比 ","date":"2024-08-06T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kubernetes%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE-ingress/","title":"Kubernetes的服务访问-Ingress"},{"content":"由于直接访问Pod存在一下问题：\n每个Pod在启动后才会被分配一个可独立访问的IP，与其生命周期绑定，在Pod启动前并不知道Pod的IP地址。 当Pod被删除或者Pod所在节点故障时，Kubernetes会根据副本期望数重新拉起新pod，旧的PodIP可能无法正常访问。 应用往往有多个副本实例（Pod），多个副本实例共同对外提供服务。使用单一的PodIP进行访问不能实现Pod间负载均衡。 所以Kubernetes引入Service解决Pod的访问问题\n添加一个Service，即可通过Service来访问Pod，Service有一个固定IP的地址，将访问它的流量转发给Pod，具体转发给哪些Pod通过LabelSelector来选择。\n创建Service 示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion: v1 kind: Service metadata: name: nginx # Service的名称 spec: selector: # 标签选择器，选择包含app=nginx标签的Pod app: nginx ports: - name: service0 targetPort: 80 # Pod的端口 port: 8080 # Service对外暴露的端口 protocol: TCP # 转发协议类型，支持TCP和UDP type: ClusterIP # Service的类型 示例创建一个名为“nginx”的Service，通过selector选择到标签为“app:nginx”的Pod，目标Pod的端口为80，Service对外暴露的端口为8080，Service类型为ClusterIP，创建后kubernetes会自动为Service分配一个IP地址，如图示的10.247.124.252。\n其他pod可通过ClusterIP:Port的形式访问到后端Pod。\n使用Service 将上述Service的定义保存至nginx-svc.yaml文件中，使用kubectl命令创建该Service。\n1 2 3 4 5 6 7 $ kubectl create -f nginx-svc.yaml service/nginxcreated $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE kubernetes ClusterIP 10.247.0.1 \u0026lt;none\u0026gt; 443/TCP 7h19m nginx ClusterIP 10.247.124.252 \u0026lt;none\u0026gt; 8080/TCP 5h48m 可以看到Service有个Cluster IP，这个IP是固定不变的，除非Service被删除，所以可以使用ClusterIP在集群内部访问Service。\nServiceName访问Service 除了用ClusterIP的形式访问Service，也可以用ServiceName的形式来访问Service。\n用ServiceName的形式来访问Service时，就需要DNS插件进行域名解析，在安装Kubernetes时，会默认要求安装CoreDNS插件。\n在kube-system命名空间下可以查看到运行CoreDNS的Pod。 kubectl get po --namespace=kube-system\n访问形式： \u0026lt;ServiceName\u0026gt;.\u0026lt;namespace\u0026gt;.svc.cluster.local 实际上在同一个命名空间中可以省略\u0026lt;namespace\u0026gt;.svc.cluster.local, 直接用ServiceName, 因为在同一个DNS搜索域中。\n例如之前创建的名为nginx的Service，直接通过“nginx:8080”就可以访问到Service，进而访问后台Pod。\nPod以ServiceName的形式也就是“ServiceName:Port”的形式访问时，CoreDNS就会将ServiceName解析为ClusterIP，从而访问到后端Pod。\n实现原理 Service是如何做到使客户端或其他Pod能够稳定访问到一组运行着特定服务的后端Pod呢？\n调用kubectldescribe命令查看Service的信息，则会看到如下回显：\n1 2 3 4 5 $ kubectl describe svc nginx Name: nginx ...... Endpoints: 172.16.2.132:80,172.16.3.6:80,172.16.3.7:80 ...... 可以看到一个Endpoints，Endpoints同样也是Kubernetes的一种资源对象。Kubernetes正是通过Endpoints监控到Pod的IP，从而让Service能够发现Pod。如执行命令kubectlget endpoints查看Endpoints的详细信息。\n1 2 3 $ kubectlget endpoints NAME ENDPOINTS AGE nginx 172.16.2.132:80,172.16.3.6:80,172.16.3.7:80 5h48m 配置了selector的Service在创建时，会自动创建一个同名的Endpoints，通过Label Selector将带有相应标签的Pod筛选出来，Endpoints将这些Pod的IP及端口信息记录下来。\n通过如下命令查看Pod的IP，可看到运行着nginx的Pod的IP与前述Endpoints对象维护的IP一致。\n1 2 3 4 5 $ kubectl get po -o wide NAME READY STATUS RESTARTS AGE IP NODE nginx-869759589d-dnknn 1/1 Running 0 5h40m 172.16.3.7 192.168.0.212 nginx-869759589d-fcxhh 1/1 Running 0 5h40m 172.16.3.6 192.168.0.212 nginx-869759589d-r69kh 1/1 Running 0 5h40m 172.16.2.132 192.168.0.94 如果删除一个Pod，Deployment会将Pod重建，新的Pod IP会发生变化。\n1 2 3 4 5 6 7 8 $ kubectldelete po nginx-869759589d-dnknn pod \u0026#34;nginx-869759589d-dnknn\u0026#34; deleted $ kubectlget po -o wide NAME READY STATUS RESTARTS AGE IP NODE nginx-869759589d-fcxhh 1/1 Running 0 5h41m 172.16.3.6 192.168.0.212 nginx-869759589d-r69kh 1/1 Running 0 5h41m 172.16.2.132 192.168.0.94 nginx-869759589d-w98wg 1/1 Running 0 7s 172.16.3.10 192.168.0.212 再次查看Endpoints，会发现Endpoints的内容也随着Pod发生了变化。\n实际上，具体的Service流量路由是Kube-Proxy组件和Iptables来共同实现的。\n在Service创建时Kubernetes会分配IP给Service，同时通过APIServer通知所有kube-proxy有新的Service创建了，kube-proxy收到通知后通过iptables记录Service和Pod的IP/端口对的关系，从而让Service在节点上可以被查询到。\niptables是运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的处理和转发，可以将iptables理解为是一系列的规则，实现从Service到Pod的流量转发。\n除了记录Service和Pod的IP/端口对的关系，kube-proxy还会监控Service和Endpoints的变化，从而保证Pod重建后仍然能通过Service访问到Pod。\n下图是一个实际访问Service的图示，Pod X访问Service（10.247.124.252:8080），在发送数据包时，在节点上根据iptables规则，目的IP:Port被随机替换为后端Pod组中某一个Pod的IP:Port，从而通过Service访问到实际的Pod。\nService的类型 Service的类型除了ClusterIP还有NodePort、LoadBalancer和Headless，这几种类型的Service有着不同的用途。\nClusterIP：用于在集群内部互相访问的场景，通过ClusterIP访问Service。 NodePort：用于从集群外部访问的场景，通过节点上的端口访问Service。 LoadBalancer：用于从集群外部访问的场景，其实是NodePort的扩展，通过一个特定的LoadBalancer访问Service，这个LoadBalancer将请求转发到节点的NodePort，而外部只需要访问LoadBalancer。 特殊的Service类型 – Headless Service：用于Pod间的互相发现。 NodePort 1 2 3 4 5 6 7 8 9 10 11 12 apiVersion: v1 kind: Service metadata: name: nodeport-service spec: type: NodePort ports: - port: 8080 target: 80 nodePort: 30100 selector: app: nginx 首先使用上面的YAML文件创建一个NodePort类型的Service，其中：\nType：指定该Service类型为NodePort。 spec.nodePort：可指定节点开放的端口，本例中指定了该端口为“30120”，如果不进行指定，kubernetes master将从给定的配置范围内（默认：30000~32767）分配端口。 Service创建完成后，可以通过“节点的IP:Port”的形式将流量转发到相应的Service，最后转发到后端Pod，NodePort类型的Service也会被分配一个ClusterIP。\nNodePort类型的Service可以让Kubemetes集群每个节点上监听一个相同的端口，外部访问请求首先访问节点IP:NodePort，对应节点将这些请求转发给Service对应的Endpoints（即PodIP:targetPort）。\nLoadBalancer LoadBalancer本身并不是Kubernetes的组件，这部分通常是由云服务厂商提供，不同厂商的Kubernetes集群与LoadBalancer的对接实现各不相同，这里以华为云对接弹性负载均衡ELB服务为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 apiVersion: v1 kind: Service metadata: annotations: kubernetes.io/elb.id: 3c7caa5a-a641-4bff-801a-feace27424b6 labels: app: nginx name: nginx spec: type: LoadBalancer selector: app: nginx loadBalancerIP: 10.78.42.242 ports: - name: service0 port: 80 protocol: TCP targetPort: 80 nodePort: 30120 上面为一个LoadBalancer类型的Service实例的YAML文件，其中：\nmetadata.annotations：表示CCE的LoadBalancer类型Service需要配置的参数，表示这个Service绑定哪个ELB实例。 loadBalancerIP：指定ELB实例的IP地址。 type：指定该Service类型为LoadBalancer。 使用该YAML文件创建LoadBalancer类型的Service后，可以通过ELB的IP:Port访问到后台Pod。\nLoadBalancer类型的Service其实是NodePort类型Service的扩展，通过一个特定的LoadBalancer访问Service，该LoadBalancer将请求转发到节点的NodePort。(华为云云原生2.0网络支持ELB直通PodIP，无需经过NodePort转发。)\nHeadless Service 通过ClusterIP可以实现Pod的内部访问，通过NodePort和LoadBalancer可以实现Pod的外部访问，那么如何实现一个Service内部的Pod之间的互相访问呢？\nHeadlessService通过使用DNS，为每个Pod提供固定的域名，这样Pod之间就可以使用域名访问，即便Pod被重新创建而导致Pod的IP地址发生变化，这个域名也不会发生变化，从而实现Service内部的Pod之间的相互访问。\n1 2 3 4 5 6 7 8 9 10 11 12 apiVersion: v1 kind: Service metadata: name: nginx labels: app: nginx spec: ports: - name: nginx port: 80 clusterIP: None 使用上面的YAML文件创建一个Headless类型的Service，其中：\nspec.ports.name：指定Pod间通信端口名称，这里设置为“nginx”； spec.ports.port：指定Pod间通信端口号，这里设置为“80”； spec.selector.app：指定选择标签为“app: nginx”的Pod； spec.clusterIP：必须设置为None，表示Headless Service。 创建Headless Service 将上述的内容保存到headless.yaml中并执行创建命令kubectl create -f headless.yaml\n创建完成后查询Service kubectl get svc\n1 2 NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx ClusterIP None\u0026lt;none\u0026gt; 80/TCP 5s Headless Service创建后，每个Pod的IP都会有下面格式的域名：\u0026lt;pod-name\u0026gt;.\u0026lt;svc-name\u0026gt;.\u0026lt;namespace\u0026gt;svc.cluster.local\n同样的，在同一个搜索域下的.\u0026lt;namespace\u0026gt;.svc.cluster.local 可以省略\n","date":"2024-08-06T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kubernetes%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE-service/","title":"Kubernetes的服务访问-Service"},{"content":"应用配置存在的问题：\n可变的配置信息：如数据库的配置、证书的配置、应用自定义配置等； 敏感信息的存储和使用：如密码、token等。 Kubernetes应用配置：\nConfigMap：管理一般可变配置信息； Secret: 敏感信息配置，信息采用base-64编码进行保存。 ConfigMap ConfigMap是一种存储非敏感数据的资源对象，以\u0026lt;key-value\u0026gt;形式存储配置数据。\nConfigMap设计要素：\n解耦应用程序（镜像）和配置参数； 不用于存储大块数据（\u0026lt;=1 MB）。 ConfigMap主要服务于Pod：\n为容器提供环境变量； 为容器提供命令行参数； 为容器提供配置文件。 定义ConfigMap： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 apiVersion: v1 kind: ConfigMap metadata: name: game-demo data: # 简单键值对 player_initial_lives: 3 ui_properties: | enemy.types=aliens,monsters player.maximum-lives=5 # 文件或目录: 文件名为Key user-interface.properties: color.good=purple color.bad=yellow allow.textmode=true 使用ConfigMap 使用ConfigMap配置环境变量: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 apiVersion: v1 kind: Pod metadata: name: configmap-test-demo spec: containers: - name: demo image: alpine command: [\u0026#34;sleep\u0026#34;, \u0026#34;3600\u0026#34;] env: - name: TEST_1 valueFrom: configMapKeyRef: # 使用ConfigMapKeyRef从ConfigMap中拿到key的Value并绑定到环境变量TEST_1 name: game-demo key: player_initial_lives - name: TEST_2 valueFrom: configMapKeyRef: # 同上 name: game-demo key: ui_properties_file_name 使用ConfigMap挂载配置文件: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 apiVersion: v1 kind: Pod metadata: name: configmap-demo-pod spec: containers: - name: demo image: alpine volumeMounts: - name: config mountPath: /config readOnly: true volumes: - name: config ConfigMap: name: game-demo items: # 存在Items时，config被定义为一个目录 - key: game.properties path: game.properties Secret Secret是一种资源对象，以\u0026lt;key-value\u0026gt;形式存储敏感数据（密码，token等）。\nSecret设计要素：\n数据采用base-64编码保存（非加密）； 通常结合RBAC rules来加强安全性。 Secret主要服务于Pod：\n为容器提供环境变量； 为容器提供镜像仓库密钥（由kubelet使用）； 为容器提供配置文件。 定义一个Secret 1 2 3 4 5 6 7 8 apiVersion: v1 kind: Secret metadata: name: mySecret type: Opaque data: username: YWRtaW4= password: MWYyZDFlMmU2N2Rm 使用Secret 使用Secret配置环境变量: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 apiVersion: v1 kind: Pod metadata: name: mypod spec: containers: - name: mycontainer image: redis env: - name: SECRET_USERNAME valueFrom: secretKeyRef: name: mysecret key: username - name: SECRET_PASSWORD valueFrom: secretKeyRef: name: mysecret key: password 使用Secret挂载配置文件: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 apiVersion: v1 kind: Pod metadata: name: mypod spec: containers: - name: mypod image: redis volumeMounts: - name: foo mountPath: \u0026#34;/etc/foo\u0026#34; readOnly: true volumes: - name: foo secret: secretName: mysecret # foo被定义为一个文件 optional: false ","date":"2024-08-06T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kubernetes%E7%9A%84%E9%85%8D%E7%BD%AE%E6%9E%B6%E6%9E%84/","title":"Kubernetes的配置架构"},{"content":"Kube-ApiServer的List-Watch机制 我们知道kube-apiserver提供了一个Kubernetes中各种资源的增删改查的接口，不仅需要对内部其他四个组件提供服务，还需要给外部的用户以及集群内可能安装的插件使用，因此它接收到的请求量是十分巨大的，为了减少这种请求量，降低kube-apiserver的压力，便设计出了list-watch机制。\nList-watch是Kubernetes统一的异步消息处理机制，各组件间协同都采用该机制进行通信，对系统的性能、数据一致性起到关键性的作用，为声明式风格的API奠定了良好的基础。它是优雅的通信方式，是Kubernetes架构的精髓。\nList-watch由list和watch组成：\nlist调用资源的list API罗列资源，获取静态的所有数据，主要用于查询，基于HTTP短链接实现。 watch调用资源的watch API，监听每个资源的增删改事件，基于HTTP长链接实现。 一个异步消息的系统，对消息机制有至少如下四点要求： 消息的可靠性: List API可以查询当前的资源状态，客户端通过期望的状态和实际的状态的对比，纠正状态不一致的资源，并可解决消息丢失的问题。 消息的实时性: List-watch机制下，每当apiserver的资源产生状态变更事件，都会将事件及时的推送给客户端，从而保证了消息的实时性。 消息的顺序性: 在并发的场景下，客户端在短时间内可能会收到同一个资源的多个事件，为保证资源的最终状态，K8S在每个资源的事件中都带一个resourceVersion的标签，这个标签是递增的数字，所以当客户端并发处理同一个资源的事件时，它就可以对比此标签来保证最终的状态和最新的事件所期望的状态的一致。 高性能: 虽然仅通过周期性调用list API也能达到资源最终一致性的效果，但是周期性频繁的轮询大大的增大了开销，增加apiserver的压力。而watch作为异步消息通知机制，复用一条长链接，保证实时性的同时也保证了性能。 List List API可以查询当前的资源状态，客户端通过期望的状态和实际的状态的对比，纠正状态不一致的资源，并可解决消息丢失的问题。\nWatch Watch是如何通过HTTP长链接接收apiserver发来的资源变更事件呢？秘诀就是Chunked transfer encoding（分块传输编码），它首次出现在HTTP/1.1。\nWatch是通过HTTP长连接实现的，其秘诀就是通过响应头中声明Chunked transfer encoding（分块传输编码）。\nHTTP分块传输编码允许服务器为动态生成的内容维持HTTP持久链接。通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。使用分块传输编码，数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。\n通过CURL命令watch pods资源 当客户端调用watch API时，apiserver在response的HTTP Header中设置Transfer-Encoding的值为chunked，表示采用分块传输编码，客户端收到该信息后，便和服务端进行链接，并等待下一个数据块，即资源的事件信息。\n1 2 3 4 5 6 7 8 9 $ curl -ihttp://{kube-api-server-ip}:8080/api/v1/watch/pods?watch=yes HTTP/1.1 200 OK Content-Type: application/json Transfer-Encoding: chunked Date: Thu, 02 Jan 2020 20:22:59 GMT {\u0026#34;type\u0026#34;:\u0026#34;ADDED\u0026#34;, \u0026#34;object\u0026#34;:{\u0026#34;kind\u0026#34;:\u0026#34;Pod\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,...}} {\u0026#34;type\u0026#34;:\u0026#34;ADDED\u0026#34;, \u0026#34;object\u0026#34;:{\u0026#34;kind\u0026#34;:\u0026#34;Pod\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,...}} {\u0026#34;type\u0026#34;:\u0026#34;MODIFIED\u0026#34;, \u0026#34;object\u0026#34;:{\u0026#34;kind\u0026#34;:\u0026#34;Pod\u0026#34;,\u0026#34;apiVersion\u0026#34;:\u0026#34;v1\u0026#34;,...}} Kubernetes基于list-watch机制的控制器架构 ","date":"2024-08-05T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kube-apiserver%E7%9A%84list-watch%E6%9C%BA%E5%88%B6/","title":"Kube-ApiServer的List-Watch机制"},{"content":"我们可以使用负载资源来管理一组Pods，通过配置Controller来保证处于运行状态的Pod个数是正确的，且其状态与所指定的状态相一致。两者通过label-selector和owerReference相关联，Pod通过工作负载实现应用的运维，如伸缩、升级等。\nKubernetes内置的工作负载有：\n无状态工作负载：ReplicaSet、Deployment 有状态工作负载：StatefulSet 守护进程工作负载：DeamonSet 批处理工作负载：Job/CronJob Deployment ReplicaSet：副本控制器，用于确保Pod的一定数量的份数(replica)在运行，用于解决pod的扩容和缩容问题，通常用于无状态应用。 Deployment：通过“控制器模式”，来操作ReplicaSet对象（而非直接操作Pod对象）的个数和属性，进而实现“水平扩展/ 收缩”和“滚动更新”这两个编排动作。 Deployment - 副本管理 扩容/缩容Deployment指增加或减少它的副本数。最简单的方式是更新其yaml中的replicas字段。\nDeployment的副本机制是通过，ReplicaSet实现的。这一点可通过查看对应Pod的ownerReference字段查看：\n如果给定如下配置部署：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion: apps/v1 kind: Deployment metadata: name: nginx labels: app: nginx spec: replicas: 5 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 查询到的结果如下：\n1 2 3 4 5 6 7 8 $ kubectl get pods --output=yaml| grep ownerReference–A 6 ownerReferences: - apiVersion: apps/v1 blockOwnerDeletion: true controller: true kind: ReplicaSet name: nginx-7848d4b86f uid: 2b3c788e-3b09-44bb-b0fb-0bd7f17ccfe8 Deployment - 滚动更新 滚动更新允许通过使用新的实例逐步更新Pod实例，零停机进行Deployment更新。新的Pod将在具有可用资源的节点上进行调度。\n滚动更新允许以下操作：\n将应用程序从一个环境提升到另一个环境（通过容器镜像更新）； 回滚到以前的版本； 持续集成和持续交付应用程序，无需停机。 操作命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 更新Deployement $ kubectl edit deploy/nginx $ kubectl set image deploy/nginxnginx=nginx:1.9.1 $ kubectl apply -f nginx.yaml 查看Deployment滚动更新情况/历史： $ kubectl rollout status deploy/nginx $ kubectl rollout history deploy/nginx 回滚： $ kubectl rollout undo deployment/nginx--to-revision=2 #不指定的话默认回滚到上一个版本 暂停/恢复： $ kubectl rollout pause deployment/nginx $ kubectl rollout resume deploy/nginx StatefulSet StatefulSet 是 Kubernetes 中的一种工作负载控制器，专门用于管理有状态的应用程序。与无状态的应用程序不同，有状态的应用程序通常需要持久化的存储和稳定的身份标识。StatefulSet 为这类应用程序提供了必要的支持。\nStatefulSet 的特点 稳定的持久化存储: StatefulSet 支持每个 Pod 与一个或多个持久卷（Persistent Volume, PV）相关联，这样每个 Pod 就有了自己独立的存储空间。 稳定的网络标识: StatefulSet 为每个 Pod 分配一个稳定的、唯一的网络标识符（通常是 DNS 名称或主机名）。这意味着 Pod 在整个生命周期内拥有相同的名称，即使 Pod 重启也不会改变。 有序部署和缩放: StatefulSet 支持有序的部署和缩放操作。这意味着 Pod 可以按顺序部署或缩放，例如从序号最小的 Pod 开始。 有序滚动更新: StatefulSet 支持有序的滚动更新，即 Pod 的更新按照一定的顺序进行，确保更新过程中应用程序的可用性。 Headless Service: StatefulSet 通常与 headless Service 结合使用，这意味着 Service 不会分配一个 Cluster IP。相反，Service 会为每个 Pod 分配一个 DNS 记录，这样每个 Pod 都可以通过自己的 DNS 名称被其他服务发现。 创建Handless服务 创建Headless服务需注意以下几点：\n服务名称和StatefulSet中的定义一致； 选择器要指向正确的Pod标签； 指定clusterIP：None。 创建步骤：\n编辑headless.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # headless.yaml apiVersion: v1 kind: Service # 对象类型为Service metadata: name: nginx labels: app: nginx spec: ports: - name: nginx# Pod间通信的端口名称 port: 80 # Pod间通信的端口号 selector: app: nginx # 选择标签为app:nginx的Pod clusterIP: None # 必须设置为None 创建Headless Service： kubectl create -f headless.yaml\n查询Service：\n1 2 3 kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE nginx ClusterIP None \u0026lt;none\u0026gt; 80/TCP 5s 创建 StatefulSet 创建并编辑yaml文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 apiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: selector: matchLabels: app: nginx serviceName: nginx replicas: 3 template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www annotations: everest.io/disk-volume-type: SAS - spec: accessModes: - ReadWriteOnce resources: requests: storage: 1Gi storageClassName: csi-disk 创建StatefulSet kubectl apply -f web.yaml 创建完成后，可看到Pod名称按序号排序： 1 2 3 4 5 kubectl get pod NAME READY STATUS RESTARTS AGE web-0 1/1 Running 0 5m28s web-1 1/1 Running 0 5m21s web-2 1/1 Running 0 4m56s 后台已创建三个PVC，名称相同，以序号排序，依次和PV做绑定： 1 2 3 4 NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE stor-web-0 Bound myPV1 1Gi RWO my-sc 65s stor-web-1 Bound myPV2 1Gi RWO my-sc 58s stor-web-2 Bound myPV3 1Gi RWO my-sc 33s 使用nslookup查看DNS记录，可以看到对该服务的访问直接指向Pod： 1 2 3 4 5 Name: nginx Address 1: 10.244.1.99 web-2.nginx.default.svc.cluster.local Address 2: 10.244.2.120 web-0.nginx.default.svc.cluster.local Address 3: 10.244.0.25 web-1.nginx.default.svc.cluster.local 副本管理 扩容/缩容StatefulSet指增加或减少它的副本数。这可以通过更新replicas字段完成。\n当缩容StatefulSet时，可以看到Pod停止的顺序为从序号最高的开始降序终止，并且只有在前一个pod被完全终止后，下一个才开始终止。升级时，也是以相同顺序处理。\nStatefulSet的副本管理由StatefulSet控制器实现的。这一点可通过查看对应Pod的ownerReference字段查看：\n1 2 3 4 5 6 7 8 ownerReferences: - apiVersion: apps/v1 blockOwnerDeletion: true controller: true kind: StatefulSet # kind: StatefulSet # name: web uid: 0230cddd-5746-4f20-82c5-25253180975e DaemonSet DaemonSet（守护进程集）部署的副本Pod会分布在各个Node上。它具备以下特点：\n确保每一个节点或者期望的节点（通过nodeSelector实现）上运行一个Pod； 新增节点时自动部署一个Pod； 移除节点时自动删除Pod。 通过yaml创建DaemonSet的方式与创建Deployment的方式相似，区别在于：\nkind选择DeamonSet； 不需要规定replicas项。 操作步骤： 创建Yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion: app/v1 kind: DaemonSet metadata: name: nginx-daemonset spec: selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containors: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 应用配置文件 kubectl apply -f daemonset.yaml 查看创建的Pod kubectl get pod -o wide 如果将一个Pod从Node上删除，会自动重启一个新的 当Kubernetes的Node出现故障时，相应的Pod也将被移除，不会在其他的节点上启动新的Pod。 Job / CronJob Job主要处理一些短暂的一次性任务，任务结束后资源释放，不需要保证应用得实时可用。\nJob执行一次性任务：\nkind：选择Job。 completions：当前的任务需要执行的Pod数量。 parallelism：表示最多有多少个并发执行的任务。 restartPolicy：只能选择Never或OnFailure。 backoffLimit：参数指定job失败后进行重试的次数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 apiVersion: batch/v1 kind: Job metadata: name: pi spec: completions: 1 parallelism: 1 backoffLimit: 3 template: #Pod 模板 spec: containers: - name: pi image: perl:latest command: [\u0026#34;perl\u0026#34;, \u0026#34;-Mbignum=bpi\u0026#34;, \u0026#34;-wle\u0026#34;, \u0026#34;print bpi(200)\u0026#34;] restartPolicy: onFailure 应用上述YAML kubectl apply -f job.yaml 查看Job kubectl get job 当运行结束后Job会自动被停止并清理。 CronJob CronJob是一种特殊的Job，主要处理周期性或者重复性的任务。\nCronJob是一种特殊的Job，它能够按照时间对任务进行调度，与我们熟悉的crontab非常相似。我们可以使用Cron格式快速指定任务的调度时间：\n在给定时间点只运行一次； 在给定时间点周期性地运行。 Schedule格式：\n1 2 3 4 5 6 7 8 9 10 与Linux Crontab 的语法一致。 ┌───────────── 分 (0 - 59) │ ┌───────────── 时 (0 - 23) │ │ ┌───────────── 月中的天 (1 - 31) │ │ │ ┌───────────── 月份 (1 - 12) │ │ │ │ ┌───────────── 周几 (0 - 6) (周日开始，部分系统中7是周日) │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ * * * * * 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 apiVersion: batch/v1 kind: Job metadata: name: pi spec: schedule: \u0026#34;*/1 * * * *\u0026#34; # 与Cornd的语法保持一致 jobTemplate: # Job模板 completions: 1 parallelism: 1 backoffLimit: 3 template: spec: # Pod模板 containers: - name: pi image: perl:latest command: [\u0026#34;perl\u0026#34;, \u0026#34;-Mbignum=bpi\u0026#34;, \u0026#34;-wle\u0026#34;, \u0026#34;print bpi(200)\u0026#34;] restartPolicy: onFailure 根据yaml创建CronJob对象之后，每分钟都会创建新的Job对象，所有的CronJob创建的任务都会带有调度时的时间戳。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ kubectlget cronjob--watch NAME SCHEDULE SUSPEND ACTIVE LAST SCHEDULE AGE pi */1 * * * * False 0 \u0026lt;none\u0026gt; 3s pi */1 * * * * False 1 1s 7s $ kubectlget job --watch NAME COMPLETIONS DURATION AGE pi-1551660600 0/3 0s 0s pi-1551660600 1/3 16s 16s pi-1551660600 2/3 31s 31s pi-1551660600 3/3 44s 44s pi-1551660660 0/3 1s pi-1551660660 0/3 1s 1s pi-1551660660 1/3 14s 14s pi-1551660660 2/3 28s 28s pi-1551660660 3/3 42s 43s ","date":"2024-08-05T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kubernetes%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8D%95%E5%85%83-%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD/","title":"Kubernetes的服务单元 - 工作负载"},{"content":"Kubernetes的核心 - Pod 在Kubernetes中，pods是能够创建、调度、和管理的最小部署单元，是一组容器的集合，而不是单独的应用容器。\n同一个Pod里的容器共享同一个网络命名空间，IP地址及端口空间。\n从生命周期来说，Pod是短暂的而不是长久的应用。Pods被调度到节点，保持在这个节点上直到被销毁。\n下面是一个定义Pod的基本要素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 apiVersion: v1 kind: Pod metadata: name: redis-django label: app: webapp spec: containers: - name: key-value-store image: redis - name: frontend iamge: django Pod的生命周期 Pod的status字段是一个PodStatus对象，PodStatus中有一个phase字段。phase是Pod在其生命周期中的简单宏观概述。\nPodStatus对象还包含一个PodCondition。数组的每个元素都有一个type字段和一个status字段。 type字段是字符串，可能的值有\nPodScheduled Ready Initialized Unschedulable ContainersReady。 status字段是一个字符串，可能的值有\nTrue False Unknown 容器的生命周期和重启策略 一旦调度器将Pod分派给某个节点，kubelet就通过runtime为Pod创建容器。要检查Pod中容器的状态，你可以使用kubectl describe pod \u0026lt;pod 名称\u0026gt;。\n容器的状态有三种：\nWaiting （等待） Running（运行中） Terminated（已终止） 如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，kubelet将根据Pod的restartPolicy自动执行修复操作。此字段可能取值包括Always、OnFailure和Never，默认值是Always。\n1 2 3 4 5 6 7 8 9 10 11 12 13 apiVersion: v1 kind: Pod metadata: name: command-demo labels: purpose: demonstrate-command spec: containers: - name: command-demo-container image: debian command: [\u0026#34;printenv\u0026#34;] args: [\u0026#34;HOSTNAME\u0026#34;, \u0026#34;KUBERNETES_PORT\u0026#34;] restartPolicy: Always 容器 Infra/PauseContainer： 基础容器, pod中所有容器的父容器，为其他容器提供共享的命名空间和网络空间\n用户不可见，无需感知。 InitContainers： 初始化容器，一般用于服务等待处理以及注册Pod信息等。\n先于业务容器开始执行； 顺序执行，执行成功退出（exit 0），全部执行成功后开始启动业务容器。 Containers： 业务容器。\n并行启动，启动成功后一直Running。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 apiVersion: v1 kind: Pod metadata: name: myapp-pod label: app: myapp spec: initContainers: - name: init-container image: busybox command: [\u0026#39;sh\u0026#39;, \u0026#39;-c\u0026#39;, \u0026#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;\u0026#39;] - name: init-mydb image: busybox command: - sh - -c - until nslookup mydb; do echo waiting for mydb; sleep 2; done; containers: - name: myapp-container image: busybox command: [\u0026#39;sh\u0026#39;, \u0026#39;-c\u0026#39;, \u0026#39;echo The App is Running ... \u0026amp;\u0026amp; sleep 3600\u0026#39;] 启动命令 在创建Pod时，可以为其下的容器设置启动时要执行的命令和参数。\n启动命令：\ncommand: 设置命令，替换镜像中的entrypoint和CMD。 args: 设置命令的参数，作为entrypoint的入参。 查看结果： 通过Pod的日志进行查看：$ kubectl logs command-demo\n镜像 Image: 镜像名称可以包含所在仓库的主机名及指定版本的标签。若不指定仓库的主机名和标签，Kubernetes默认使用Docker公共仓库，拉取最新版本镜像（:latest）。\nimagePullSecret: 若Pod创建需从私有仓库读取镜像，则可通过配置此字段提供仓库的访问凭证。为保证凭据文件的安全，可事先将其创建为Secret再进行引用。\nimagePullPolicy: 镜像拉取策略。\nIfNotPresent：优先使用本地镜像。 Always：每次容器启动时都从镜像库拉取镜像。 Never：仅使用本地镜像。 外部输入 Pod可以接收外部输入的方式： 环境变量、配置文件和密钥。\nenv: 环境变量，使用简单，但一但更改容器必须重启。 - key-value直接定义。 - valueFrom配置文件(ConfigMap)或密钥(Secret)。\nvolume: 以卷形式挂载到容器内使用，权限可控。 配置文件(ConfigMap)或密钥(Secret).\nPod配置文件的部分示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... spec: containers: env: - name: APP_NAME value: test - name: USER_NAME valueFrom: secretKey: key: username name: secret volumeMounts: mountPath: /config name: cfg volumes: name: cfg configMap: name: config items: - key: age path: age 探针(Probe) 探针（Probe）是由kubelet对容器执行的定期诊断。诊断方式主要有以下三种：\nExecAction：在容器内执行指定命令。如果命令退出时返回码为0则认为诊断成功。 TCPSocketAction：对指定端口上的容器的IP地址进行TCP检查。如果端口打开，则诊断成功。 HTTPGetAction：对指定的端口和路径上的容器的IP地址执行HTTP Get请求。如果响应的状态码大于等于200且小于400，则诊断成功。 Kubelet可以于Pod执行的两种探针类型为：\n存活探针（livenessProbe）：指示容器是否正在运行。如果存活探测失败，则kubelet会杀死容器，并且容器将受到其重启策略的影响。 就绪探针（readinessProbe）：指示容器是否准备好服务请求。如果就绪探测失败，Endpoint Controller将从与Pod匹配的所有Service的Endpoints中删除该Pod的IP地址。 用户通过spec.container.livenessProbe（或spec.container.readinessProbe）字段设置探针。Probes涉及的字段如下：\ninitialDelaySeconds：容器启动后要等待多少秒后存活和就绪探测器才被初始化。默认值为10。 periodSeconds：执行探测的时间间隔（单位：秒）。默认值为1。 successThreshold：探测器在失败后，被视为成功的最小连续成功数。默认值为1。 failureThreshold：当探测失败时，Kubernetes的重试次数。存活探测情况下的放弃就意味着重新启动容器。就绪探测情况下的放弃Pod会被打上未就绪的标签。默认值为3。 探针的示例配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 存活探针 - 检查文件/tmp/healthy 是否存在 (容器启动5s后开始，每次间隔5s) livenessProbe: exec: command: [\u0026#34;cat\u0026#34;, \u0026#34;/tmp/healthy\u0026#34;] initialDelaySeconds: 5 periodSecond: 5 # 就绪探针 - 检查端口8080是否开放(容器启动后5s开始，每次间隔10s) readinessProbe: tcpSocket: port: 8080 initialDelaySeconds: 5 periodSecond: 10 # 存活探针 - 检查http://lo:8080/healthz的状态码是否在200-399之间 livenessProbe: httpGet: path: /healthz port: 8080 httpHeaders: - name: Custom-Header value: Awesome initialDelaySeconds: 3 periodSeconds: 3 资源限制 - limit Kubernetes的资源限制是通过每个容器containerSpec的resources字段进行设置的。\nCPU资源：\n单位：以CPU为单位，也支持带小数值的使用，如：cpu: “0.5”或cpu:500m。 CPU请求（request）：创建容器时预分配的CPU资源。 CPU限制（limit）：CPU的资源上限。 内存资源：\n单位：以字节（byte）为单位，可表示为纯整数或定点整数：E、P、T、G、M、K或Ei、Pi、Ti、Gi、Mi、Ki。 内存请求（request）：创建容器时预分配的内存资源。 内存限制（limit）：内存的资源上限。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 spec: containers: - image: nginx name: nginx ports: - containerPort: 80 resources: requests: memory: \u0026#34;100Mi\u0026#34; cpu: \u0026#34;250m\u0026#34; limits: memory: \u0026#34;200Mi\u0026#34; cpu: \u0026#34;500m\u0026#34; ","date":"2024-08-05T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kubernetes%E7%9A%84%E6%A0%B8%E5%BF%83-pod/","title":"Kubernetes的核心 - Pod"},{"content":"Kubernetes调度流程及策略 在Kubernetes中，调度是指将Pod放置到合适的Node上，然后对应Node上的Kubelet才能够运行这些pod。\nPredicates vs. Priorities Predicates函数 先于Priority函数执行，用于硬条件过滤。常见策略如：\nCheckNodeCondition: 检查Node是否符合调度条件。 HostName：检查Node的名称是否为Pod的指定的Hostname。 MatchNodeSeletctor：检查Node的标签是否满足Pod的nodeSelector属性hard选择器需求。requiredDuringSchedulingIgnoredDuringExecution PodFitsResources：检查Node的资源是否满足Pod的需求。 Taint\u0026amp;Toleration：Pod容忍度设置NoSchedule或NoExecute，用来避免Pod被分配到不合适的节点上。 Priorities函数 将Predicate函数执行结果进行计算评分后排序，得分最高Node进行Pod调度。常见策略如：\nLeastRequested：按空闲度（空闲容量/总容量）进行Node排序。 BalanceResourceAllocation：资源均匀分布，必须与LeastRequested同时使用。 SelectorSpreading：对于属于同一个service、rc的Pod，尽量分散在不同的主机上。 NodeAffinity：检查Node的标签是否满足Pod的nodeSelector属性soft选择器需求。preferresDuringSchedulingIgnoredDuringExecution Taint\u0026amp;Toleration：Pod容忍度设置PreferNoSchedule。 NodeName Kubernetes支持多种自定义调度方式，指定NodeName调度是最简单的一种，可以将Pod调度到期望的节点上。\n通过spec.spec.nodeName字段强制约束将Pod调度到指定的Node节点上，这里说是“调度”，但其实指定了nodeName的Pod会直接跳过Scheduler的调度逻辑，直接写入PodList列表，该匹配规则是强制匹配。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 apiVersion: extensions/v1beta1 kind: Deployment metadata: name: tomcat-deploy spec: replicas: 1 template: metadata: labels: app: tomcat-app spec: nodeName: k8s.node1 #指定调度节点为k8s.node1 containers: - name: tomcat image: tomcat:8.0 ports: - containerPort: 8080 nodeSelector 通过kubernetes的label-selector机制进行节点选择，由scheduler调度策略MatchNodeSelector进行label匹配，调度pod到目标节点，启用NodeSelector的步骤为：\n为指定Node添加label标记。 Pod定义spec.nodeSelector字段，指定key-value键值。 $ kubectl label nodes k8s.node1 App=tomcat Phase=prod\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 apiVersion: extensions/v1beta1 kind: Deployment metadata: name: tomcat-deploy spec: replicas: 1 template: metadata: labels: app: tomcat-app spec: nodeSelector: - App: tomcat - Phase: prod #指定调度节点为带有label标记为：App=tomcat, Phase=prod的node节点 containers: - name: tomcat image: tomcat:8.0 ports: - containerPort: 8080 nodeAffinity 相较nodeName和nodeSelector，Affinity/Anti-affinity极大地拓展了可以表达的约束类型，语法更灵活，不仅仅支持“与”（AND），且可以指明非强制规则（preferred），以及你可以使用拓扑分布来约束Pod在集群内的分布。\n目前支持两种类型的Node Affinity，可以视它们为“硬需求”和“软需求”。\nrequiredDuringSchedulingIgnoredDuringExecution \u0026amp;\u0026amp; preferredDuringSchedulingIgnoredDuringExecution\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 apiVersion: v1 kind: Pod metadata: name: with-node-affinity spec: affinity: # 亲和关系 nodeAffinity: # 节点亲和 requiredDuringSchedulingIgnoredDuringExecution: # 硬需求 - 强制需要 nodeSelectorTerms: - matchExpressions: - key: kubernetes.io/os operator: In values: linux preferredDuringSchedulingIgnoredDuringExecution: # 软需求 - 优先需要 - weight: 1 preference: matchExpressions: - key: another-node-label-key operator: In values: another-node-label-value containers: - name: with-node-affinity image: k8s.gcr.io/pause:2.0 PodAffinity Podaffinity/anti-affinity让我们基于Pod标签，而不是基于节点上的标签来约束Pod可以调度到的节点。与节点亲和性一样，当前有两种类型的podAffinity:\nrequiredDuringSchedulingIgnoredDuringExecution preferredDuringSchedulingIgnoredDuringExecution Pod间亲和性通过pod.spec中affinity字段下的podAffinity字段进行指定；而Pod间反亲和性通过pod.spec中affinity字段下的podAntiAffinity字段进行指定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 spec: affinity: podAffinity: requiredDuringSchedulingIgnoredDuringExecution: - labelSelector: matchExpressions: - key: security operator: In values: S1 topologyKey: topology.kubernetes.io/zone podAntiAffinity: preferredDuringSchedulingIgnoredDuringExecution: - weight: 100 podAffinityTerm: labelSelector: matchExpressions: - key: security operator: In values: S2 topologyKey: topology.kubernetes.io/zone Taint(污点) \u0026amp; Toleration(容忍度) 节点亲和性是Pod的一种属性，它能让Pod被调度到一类特定的节点上。而污点则相反，它使节点排斥一类特定的Pod（由容忍度决定），从而避免Pod调度到该节点上。\n污点（Taint）： 每个节点上都可以应用一个或多个污点，污点是与“效果”相关联的键值对，效果包括：\nNoSchedule：不能容忍此污点的Pod不会被调度到节点上；现有Pod不会从节点中逐出。 PreferNoSchedule：Kubernetes会避免将不能容忍此污点的Pod安排到节点上。 NoExecute：如果Pod已在节点上运行，则会将该Pod从节点中逐出；如果尚未在节点上运行，则不会将其安排到节点上。 容忍度（Tolerations）： 容忍度应用于Pod上，允许（但并不要求）Pod调度到带有与之匹配的污点的节点上。\n操作方法： 通过kubectl给Node1增加污点：\n$ kubectl taint nodes node1 key1=value1:NoSchedule\n移除上述污点：\n$ kubectl taint nodes node1 key1=value1:NoSchedule-\n我们可以在pod.spec中定义Pod的容忍度。下面2个的忍度均与上面例子中使用kubectl taint命令创建的污点相匹配，因此如果一个Pod拥有其中的任何一个容忍度都能够被分配到node1。\n1 2 3 4 5 6 7 8 9 Kind: Pod ... spec: tolerations: - key: \u0026#34;key1\u0026#34; operator: \u0026#34;Equal\u0026#34; value: \u0026#34;value1\u0026#34; effect: \u0026#34;NoSchedule\u0026#34; ... 1 2 3 4 tolerations: - key: \u0026#34;key1\u0026#34; operator: \u0026#34;Exists\u0026#34; effect: \u0026#34;NoSchedule\u0026#34; ","date":"2024-08-05T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kubernetes%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B%E5%8F%8A%E7%AD%96%E7%95%A5/","title":"Kubernetes调度流程及策略"},{"content":"Kubernetes概览 Kubernetes是Google开源的容器集群管理系统；它构建在容器技术之上，为容器化的应用提供资源调度，部署运行，服务发现，扩容缩容等一整套功能，本质上是基于容器技术的Micro-PaaS平台，Kubernetes的灵感来源于Google内部的Borg系统。\nKubernetes将容器宿主机组成集群，统一进行资源调度，自动管理容器生命周期，提供跨节点服务发现和负载均衡；更好的支持微服务理念，划分、细分服务之间的边界，比如lablel、pod等概念的引入。\nKubernetes特点： 轻量，迁移方便，部署快捷，插件化，可扩展。\n关键对象 模型对象：\nPod: 能够创建、调度和管理的最小部署单元。 Service: 一个Pods的逻辑集合和访问这个集合的策略。 Rs/Rc/DaemonSet: 确保Pod的一定数量的份数（replica）在运行。 Label \u0026amp; Selector: 定义了这些对象的识别属性，用来识别和组织这些对象。 核心组件：\nMaster节点的组件 kube-ApiServer: 提供Kubbernets API，提供对PODs, Services, ReplicationController等对象的CRUD处理的REST操作，验证它们在Etcd中更新相应的对象API，不仅面向最终用户，也面向开工具和拓展的开发者，是开放生态的基础。 Kube-Scheduler: 通过访问Kubernetes中/binding API, Scheduler负责在各个节点上分配。Schedulers是插件式的，K8s可以支持用户自定义的Scheduler。 Kube-Contorller-Marager: 控制器循环监听集群中资源状态，按照预期状态对资源进行管理。每个控制器就是将对应的资源牵引到期望的状态Kubernetes将来可以把这些控制器拆分并提供可插拔的组件。 Node Kubelet: Kubelet管理pods和它们的容器、镜像、卷等。 Kube-Proxy: Kube-proxy是一个简单的网络代理和负载均衡器。它具体实现Service模型，每个Service都会在所有的Kube-Proxy节点上体现。根据Service的selector所覆盖的Pods, 对这些Pods做负载均衡来服务于Service的访问者。 Container Runtime: 容器运行环境是负责运行容器的软件。支持的运行时: Docker、containerd、CRI-O 以及任何实现Kubernetes CRI（容器运行环境接口）。 功能特性\n资源调度: 通过 Scheduler 部署启动: 容器运行时(Docker) 运行监控: Heapster / cAdvisor 服务发现: 通过环境变量和DNS 错误处理 扩容缩容: 通过Replication Controller 对象描述 Kubernetes中的对象使用Yaml(主要)或JSON描述。主要分为4部分：\ntypeMeta: 对象类型的元信息，声明对象使用哪个API版本，哪个类型的对象。 objectMeta: 对象的元信息，包括对象名称、使用的标签等。 spec: 对象的期望状态，例如对象使用什么镜像、有多少副本等。 status: 对象的实际状态，只能在对象创建后看到，创建对象时无需指定。由Kubernetes定义，该字段对于最终用户是只读的 示例文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # typeMeta: apiVersion: apps/v1 kind: Deployment # ObjectMeta: metadata: name: nginx labels: app: nginx # 期望状态 spec: selector: matchLabels: app: nginx replicas: 3 template: metadata: lalebs: app: nginx spec: containers: - name: nginx image: nginx:alpine resources: requests: cpu: 100m memory: 200Mi limits: cpu: 100m memory: 200Mi imagePullSecrets: - name: default-secret # 实际状态 status: {} 工作流程 ","date":"2024-08-01T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kubernetes%E6%A6%82%E8%A7%88/","title":"Kubernetes概览"},{"content":"核心组件 Etcd (公共核心组件) etcd是一个分布式key-value存储系统，为Kubernetes提供原数据的存储。\n接口简单： 通过客户端或HTTP的方式访问； 数据表示简单： 存储key-value数据，可理解为一个有序的map； 方便数据订阅： 支持watch机制； Api-Server (Master) Api-Server通过Master节点上的kube-apiserver进程提供服务，该服务是集群内各个功能模块之间数据交互和通信的中心枢纽，实现了 Kubernetes 对象模型（如 Pods, Services, Deployments 等）的 CRUD 操作。\n由于API Server承担了系统内关键的数据通信部分，所以API Server的性能高低决定了集群性能的高低。\n使用 etcd 数据库作为持久化存储后端。所有 Kubernetes 对象的状态都保存在 etcd 中。\nAPI Server提供的API: /api/vi - 核心API /apis - 分组API /healthz - 健康监测 /logs - 日志 /swaggerapi - SwaggerAPI (OpenAPI) /metrics - 性能度量 访问控制 授权 身份验证 准入控制 服务注册 Pod NameSpace Service Apps Storage \u0026hellip; Controller Manager (Master) 在Kubernetes中，每个Controller是一个控制回路，通过APIServer监视集群内Node、Pod的等资源的状态，并确保其当前状态（由spec字段规定）接近期望状态。\nController按照其实现方式，可以分为内部控制器和外部控制器。\nKubernetes内部几乎每种特定资源都有特定的Controller维护管理，而ControllerManager的职责便是把所有的Controller聚合起来，以达到以下目的：\n提供基础设施，启动和维持Controller的正常运行，降低Controller的实现复杂度。 通过Watch apiserver监控资源状态变化，对不同的Controller分发事件通知。 Controller工作流程 Controller Manager主要提供了一个分发事件的能力，而不同的Controller只需要注册对应的Handler来等待接收和处理事件。在Controller Manager的帮助下，Controller的逻辑可以做的非常纯粹，只需要实现相应的EventHandler即可。以Deployment controller为例:\n内部控制器 Deployment Controller： 用于管理应用程序的部署过程。 它基于 ReplicaSets 来管理 Pods，并支持滚动更新和回滚等高级部署策略。 ReplicaSet： 确保指定数量的副本（Pods）始终处于运行状态。如果 Pod 数量减少，它会自动创建新的 Pod；如果 Pod 数量超过期望值，则删除多余的 Pod。 StatefulSet Controller: 管理有状态的应用程序实例。维护持久的标识符和稳定的持久卷绑定。 DaemonSet Controller: 确保所有（或某些）节点上运行一个 Pod 的副本。常用于运行守护进程，如日志收集或监控代理。 Job Controller: 确保一个或多个任务完成指定次数的执行。通常用于批处理作业或一次性任务。 CronJob Controller: 创建基于时间的 Jobs，类似于 Unix cron 任务。 Namespace Controller: 管理 Namespace 的生命周期，包括删除 Namespace 及其关联资源。 Node Controller: 用于监控节点的状态，标记不健康的Node，并迁移其上的POD。 Endpoints Controller: 更新每个Service的Endpoint列表，以反映实际可用的Pod。 Kube-Scheduler kube-scheduler组件是kubernetes默认的调度器，kube-scheduler组件内置的预选和优选算法，主要负责把创建的Pod调度到具体的工作节点上，完成Pod到Node的调度和预绑定工作。\n工作流程 Informer组件list-watch apiserver，同步etcd中Pod（spec.nodeName）信息的变化； 将未调度Pod的信息加入队列中，同时更新Scheduler Cache缓存，并获取Node列表； 预选阶段，针对Pod和Node列表执行Predicate算法，过滤掉不合适的节点； 优选阶段，针对Pod和Node列表执行Priority算法，给节点打分，根据打分，计算出得分最高的节点； 当调度器为Pod选择了一个合适的节点时，通过Bind将Pod和节点进行绑定； 更新缓存。 Kubelet kubelet用于处理master节点下发到本节点的任务，管理Pod以及Pod中的容器。kubelet的工作核心，就是一个控制循环，即：SyncLoop。\nKube-Proxy Kube-proxy是一个简单的网络代理组件，它的作用主要是负责Service的实现。\n实现与工作原理 Kube-proxy： 在每个节点上运行一个kube-proxy服务，监听API server中Service、Endpoint及Node的变化情况。 Iptables/IPVS： Kube-proxy根据监听资源变化，操作代理后端来为服务配置负载均衡。目前Kube-proxy常用的代理模式为： Iptables：Linux内核的一项功能。kube-proxy为每一个Serive创建相应的iptables规则，并将发送到Service的VIP（Cluster IP）的流量转发后端Pod的相应端口上。 IPVS：专门用于负载均衡的Linux内核功能，其功能依赖iptables，具有更好的扩展性和性能，支持更加复杂的负载均衡算法。 ","date":"2024-08-01T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/kubernetes%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/","title":"Kubernetes核心组件"},{"content":"Async 库和Python相关关键字 async - 关键字 - 定义一个 Async函数或方法\n1 2 async def func(): pass await - 关键字 - 挂起 coroutine 的执行以等待一个 awaitable 对象。 只能在 coroutine function 内部使用。\nawait 会创建一个task，将Task放入事件循环，释放操作句柄交给调度器，阻塞上下文知道await的Task返回结果\n1 2 3 4 import asyncio async def func(): await asyncio.sleep(1) coroutine - 定义 - 协程 coroutine function - 定义 - 由 async def 定义的函数； conoutine object - 定义 - coroutine function的一个实例。 值得注意的是，当我们直接调用了一个 coroutine function 的时候，并不会调用该函数的具体内容，而是会生成一个 coroutine object，这个obj只有在asyncio 的 event_loop 中被调度。这个过程类似于我们生成器和生成器函数。\nawaitable对象 - 定义 - 可以被await语句中使用的对象，可以是coroutine function, 或实现了 __await__ 魔术方法的对象。 asyncio.run() - 函数 - 协程事件循环的入口。 asyncio.create_task() - 函数创建一个conoutine object包装为Task并加入到事件循环。 asyncio.gather(*coros_or_futures, return_exceptions=False) - 函数 - 返回给定协程futures 的未来聚合结果。\n协程将被包装在 future 中并在事件循环中进行调度。它们不一定按照传入的顺序进行安排。\n所有 future 必须共享相同的事件循环。如果所有任务都成功完成，则返回的 future 的结果是结果列表（按照原始序列的顺序，不一定是结果到达的顺序）。如果return_exceptions为True，则任务中的异常将被视为与成功结果相同，并收集在结果列表中；否则，第一个引发的异常将立即传播到返回的 future。 相关视频： ","date":"2023-02-13T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/async-%E5%8D%8F%E7%A8%8B%E5%85%A5%E9%97%A8/","title":"Async 协程入门"},{"content":"Redis-Shake 2.+ 版本\n同步过程中终止 报错： 问题原因： 在同步过程中会出现一些集群（副本）管理相关的操作指令，这些指令不应该跨集群同步。\n这些错误目前发现主要出现在源集群有slave的情况下。\n解决方案： 在配置文件中加入或修改 项： filter.command.blacklist 中追加 replconf ，用于过滤replconf 指令的同步。\n重连后全量同步过成中的RDB Save Error 报错： 1 [PANIC] restore command error key:gmv2022-09-18 00:00:00690047125391hyper1092HYPERCPC err:MISCONF Redis is configured to save RDB snapshot 问题原因 redis save rdb 失败，具体根因未知。\n解决方案 删除全部集群节点中的 rdb 和 aof 文件 并重启集群。\n","date":"2023-02-13T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/redis-shake-%E9%94%99%E8%AF%AF%E6%80%BB%E7%BB%93/","title":"Redis Shake 错误总结"},{"content":"Linux 修改指定进程的打开文件数限制 prlimit --pid {pid} --nofile=65535:65535\n查询指定PID打开的句文件柄数 lsof -n | awk '{print $2}' |sort |uniq -c |sort -nr |grep PID\n查询指定PID的limit信息 cat /proc/$PID/limits\nTelnet 自动超时退出 timeout --signal=9 {timout_sec} telnet {ip} {port}\nMySQL导出前100条数据 mysqldump -uroot -p'password' {db} --where \u0026quot;1=1 limit 100\u0026quot; \u0026gt; test.sql\n使用Python快速开启一个简单的文件服务器 python3 -m http.server (v3.4+) 或 python -m SimpleHTTPServer (v2.7+)\n","date":"2022-12-17T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/linux-%E5%B0%8F%E6%8A%80%E5%B7%A7/","title":"Linux 小技巧"},{"content":"iproute2 模块包含的子命令 ","date":"2022-11-19T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/ip%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90/","title":"ip命令解析"},{"content":"背景 ","date":"2022-11-19T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/linux%E5%88%9B%E5%BB%BA%E8%B7%AF%E7%94%B1%E7%BD%91%E5%85%B3/","title":"Linux创建路由网关"},{"content":"使用命令 ip -6 neigh\n","date":"2022-11-19T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/linux%E4%B8%8B%E6%9F%A5%E7%9C%8Bipv6%E9%82%BB%E5%B1%85%E7%9A%84%E6%96%B9%E6%B3%95/","title":"Linux下查看Ipv6邻居的方法"},{"content":"iptables 实现端口转发 1. 确保IPv4内核流量转发功能开启 1 2 echo net.ipv4.ip_forward=1 \u0026gt;\u0026gt; /etc/sysctl.conf sysctl -p 2. 配置iptables抓发规则 流量状态： Inter \u0026ndash;\u0026gt; 10.0.4.14:13389 \u0026ndash;\u0026gt; 10.1.1.10:3389\n1 2 3 4 5 # 将外网访问192.168.75.5的80端口转发到192.168.75.3:8000端口。 iptables -t nat -A PREROUTING -d 10.0.4.14 -p tcp --dport 13389 -j DNAT --to-destination 10.1.1.10:3389 # 将192.168.75.3 8000端口将数据返回给客户端时，将源ip改为192.168.75.5 iptables -t nat -A POSTROUTING -d 10.1.1.10 -p tcp --dport 3389 -j SNAT --to 10.0.4.14 3. iptables配置仅内网可以访问脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 iptables -F # 删除全部的规则 iptables -X # 删除全部自定义的链 iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT # 允许已经建立的连接 # 添加允许的IP地址段示例 iptables -A INPUT -i lo -j ACCEPT # 允许lo接口的全部流量 iptables -A INPUT -s 192.168.0.0/16 -j ACCEPT # 允许192.168.0.0/16网段的入栈流量 iptables -A INPUT -s 10.0.0.0/8 -j ACCEPT # 允许10.0.0.0/8网段的入栈流量 iptables -A INPUT -s 172.16.0.0/12 -j ACCEPT # 允许172.16.0.0/12网段的入栈流量 iptables -A INPUT -s 100.64.0.0/12 -j ACCEPT # 允许100.64.0.0/12网段的入栈流量 # 添加允许端口示例 iptables -A INPUT -p tcp --dport 8000 -j ACCEPT # 允许全部的IP地址访问8000端口 iptables -A INPUT -p tcp -s 10.0.0.0/8 --dport 8000 -j ACCEPT # 仅允许10.0.0/8网段访问8000端口 iptables -P INPUT DROP # 默认拒绝INPUT链 iptables -P OUTPUT ACCEPT # 默认允许OUTPUT链 iptables -P FORWARD DROP # 默认拒绝FORWARD链 ","date":"2022-11-17T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/iptables-%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/","title":"iptables 实现端口转发"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 #!/bin/env python3 # coding: utf8 \u0026#34;\u0026#34;\u0026#34;数据结构 - 对比工具 QA - \u0026#34;\u0026#34;\u0026#34; import csv import logging import time from typing import Union import pymssql import pymysql logger = logging.getLogger(\u0026#39;sql.contrast\u0026#39;) class SqlWriteError(Exception): pass class BaseSql: def __init__(self, host, port, user, password, db, charset=\u0026#39;utf8\u0026#39;, use_unicode=True, **kwargs): super().__init__() self.SQL_HOST = host # 主机 self.SQL_PORT = port # 端口 self.SQL_USER = user # 用户 self.SQL_PASSWD = password # 密码 self.SQL_DB = db # 数据库 self.SQL_CHARSET = charset # 编码 self.use_unicode = use_unicode # 表前缀 self.TABLE_PREFIX = kwargs.pop(\u0026#39;prefix\u0026#39;, \u0026#39;\u0026#39;) self.kwargs = kwargs self.pooled_sql = None @property def _sql(self): raise NotImplementedError def set_use_db(self, db_name): \u0026#34;\u0026#34;\u0026#34;设置当前数据库\u0026#34;\u0026#34;\u0026#34; return self._sql.select_db(db_name) def set_charset(self, charset): \u0026#34;\u0026#34;\u0026#34;设置数据库链接字符集\u0026#34;\u0026#34;\u0026#34; return self._sql.set_charset(charset) def close(self): \u0026#34;\u0026#34;\u0026#34;关闭数据库连接\u0026#34;\u0026#34;\u0026#34; self._sql.close() def read_db(self, command, args=None, ): \u0026#34;\u0026#34;\u0026#34;执行数据库读取数据， 返回结果 :param command :param args \u0026#34;\u0026#34;\u0026#34; if self.pooled_sql is not None: _sql = self.pooled_sql.connection() else: _sql = self._sql cur = _sql.cursor() cur.execute(command, args) results = cur.fetchall() cur.close() return results class MySqlAPI(BaseSql): @property def _sql(self): return pymysql.connect( host=self.SQL_HOST, port=self.SQL_PORT, user=self.SQL_USER, password=self.SQL_PASSWD, # 可以用 passwd为别名 database=self.SQL_DB, # 可以用 db 为别名； charset=self.SQL_CHARSET, use_unicode=self.use_unicode, **self.kwargs ) def tables_name(self): return [_c[0].decode() if isinstance(_c[0], bytes) else _c[0] for _c in self.read_db(\u0026#34;show tables\u0026#34;)] def columns(self, table, ): \u0026#34;\u0026#34;\u0026#34;返回table中列（字段）的所有信息 +-------+-------+------+------+-----+---------+-------+ | index | 0 | 1 | 2 | 3 | 4 | 5 | +-------+-------+------+------+-----+---------+-------+ | dict | Field | Type | Null | Key | Default | Extra | +-------+-------+------+------+-----+---------+-------+ \u0026#34;\u0026#34;\u0026#34; return self.read_db(f\u0026#39;show columns from `{table}`\u0026#39;, ) def columns_name(self, table) -\u0026gt; list: \u0026#34;\u0026#34;\u0026#34;返回 table 中的 列名在一个列表中\u0026#34;\u0026#34;\u0026#34; return [_c[0].decode() if isinstance(_c[0], bytes) else _c[0] for _c in self.columns(table)] class MsSqlAPI(BaseSql): @property def _sql(self): return pymssql.connect( host=self.SQL_HOST, port=self.SQL_PORT, user=self.SQL_USER, password=self.SQL_PASSWD, # 可以用 passwd为别名 database=self.SQL_DB, # 可以用 db 为别名； charset=self.SQL_CHARSET, **self.kwargs ) def tables_name(self): \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; return [ _c[0].decode() if isinstance(_c[0], bytes) else _c[0] for _c in self.read_db(\u0026#34;select name FROM [sysobjects] where [xtype]=\u0026#39;u\u0026#39;\u0026#34;) ] def columns(self, table): \u0026#34;\u0026#34;\u0026#34; :param table: :return: \u0026#34;\u0026#34;\u0026#34; return [ _c for _c in self.read_db(f\u0026#34;sp_columns [{table}]\u0026#34;) if _c[1] == \u0026#39;dbo\u0026#39; ] class ContrastSQL: \u0026#34;\u0026#34;\u0026#34;数据结构对比\u0026#34;\u0026#34;\u0026#34; def __init__(self, sql_obj1, sql_obj2, attention_cols: Union[dict, list] = None): self.sql_1: MySqlAPI = sql_obj1 self.sql_2: MySqlAPI = sql_obj2 if type(sql_obj1) != type(sql_obj2): raise TypeError if type(sql_obj1) == MsSqlAPI: self.check_type = \u0026#39;sqlserver\u0026#39; self.column_name = \u0026#39;COLUMN_NAME\u0026#39; self.type_name_2_index = self.mssql_type_name_2_index elif type(sql_obj1) == MySqlAPI: self.check_type = \u0026#39;mysql\u0026#39; self.column_name = \u0026#39;Field\u0026#39; self.type_name_2_index = self.mysql_type_name_2_index else: raise self.attention_cols = set( attention_cols[self.check_type] if isinstance(attention_cols, (dict,)) else attention_cols or [] ) if len(self.attention_cols) == 0: if self.check_type == \u0026#39;sqlserver\u0026#39;: self.attention_cols = self.mssql_all else: self.attention_cols = self.mysql_all logger.info( \u0026#39;=\u0026#39; * 20 + f\u0026#39;[{self.check_type.upper()}] QA({self.sql_1.SQL_DB}) \u0026lt;--\u0026gt; PROD({self.sql_2.SQL_DB})\u0026#39; + \u0026#39;=\u0026#39; * 20 ) self.com_tables = self.tables_diff() for t in self.com_tables: self.columns_diff(t) def tables_diff(self): \u0026#34;\u0026#34;\u0026#34;数据表对比\u0026#34;\u0026#34;\u0026#34; tables1 = set(self.sql_1.tables_name()) tables2 = set(self.sql_2.tables_name()) table_common = tables2 \u0026amp; tables1 logger.debug(\u0026#39;COMMON TABLE: %s\u0026#39;, table_common) if tables1 - table_common: logger.info(f\u0026#39;[{self.check_type.upper()}]QA_CLOUD. {self.sql_1.SQL_DB} 独有的表: {tables1 - table_common}\u0026#39;) if tables2 - table_common: logger.info(f\u0026#39;[{self.check_type.upper()}]PROD_CLOUD {self.sql_2.SQL_DB} 独有的表: {tables2 - table_common}\u0026#39;) return table_common mssql_all = [ \u0026#39;TABLE_QUALIFIER\u0026#39;, \u0026#39;TABLE_OWNER\u0026#39;, \u0026#39;TABLE_NAME\u0026#39;, \u0026#39;COLUMN_NAME\u0026#39;, \u0026#39;DATA_TYPE\u0026#39;, \u0026#39;TYPE_NAME\u0026#39;, \u0026#39;PRECISION\u0026#39;, \u0026#39;LENGTH\u0026#39;, \u0026#39;SCALE\u0026#39;, \u0026#39;RADIX\u0026#39;, \u0026#39;NULLABLE\u0026#39;, \u0026#39;REMARKS\u0026#39;, \u0026#39;COLUMN_DEF\u0026#39;, \u0026#39;SQL_DATA_TYPE\u0026#39;, \u0026#39;SQL_DATETIME_SUB\u0026#39;, \u0026#39;CHAR_OCTET_LENGTH\u0026#39;, \u0026#39;ORDINAL_POSITION\u0026#39;, \u0026#39;IS_NULLABLE\u0026#39;, \u0026#39;SS_DATA_TYPE\u0026#39; ] mysql_all = [ \u0026#39;Field\u0026#39;, \u0026#39;Type\u0026#39;, \u0026#39;Null\u0026#39;, \u0026#39;Key\u0026#39;, \u0026#39;Default\u0026#39;, \u0026#39;Extra\u0026#39; ] def mssql_type_name_2_index(self, name): \u0026#34;\u0026#34;\u0026#34;MSSQL COL_NAME 转索引\u0026#34;\u0026#34;\u0026#34; return self.mssql_all.index(name) def mysql_type_name_2_index(self, name): \u0026#34;\u0026#34;\u0026#34;MYSQL COL_NAME 转索引\u0026#34;\u0026#34;\u0026#34; return self.mysql_all.index(name) def columns_diff(self, table): \u0026#34;\u0026#34;\u0026#34;列差异对比\u0026#34;\u0026#34;\u0026#34; logger.info(\u0026#39;-\u0026#39; * 20 + f\u0026#39;{self.sql_2.SQL_DB}.{table}\u0026#39; + \u0026#39;-\u0026#39; * 20) def get_names(xs): return {_[self.type_name_2_index(self.column_name)] for _ in xs} def find_item(name, cols) -\u0026gt; dict: \u0026#34;\u0026#34;\u0026#34;在列信息中查找一个元素\u0026#34;\u0026#34;\u0026#34; for _c in cols: if _c[self.type_name_2_index(self.column_name)] == name: return {_: _c[self.type_name_2_index(_)] for _ in self.attention_cols} raise Exception(f\u0026#39;{name}, {cols}, {self.column_name}, {self.type_name_2_index(self.column_name)}\u0026#39;) def zip_dict(dic1: dict, dic2: dict): if dic1.keys() != dic2.keys(): raise for key in dic1.keys(): yield key, dic1[key], dic2[key] columns1: list = self.sql_1.columns(table, ) columns2: list = self.sql_2.columns(table, ) col_name1 = set(get_names(columns1)) col_name2 = set(get_names(columns2)) col_common = col_name1 \u0026amp; col_name2 logger.debug(\u0026#39;COMMON COLUMNS : %s\u0026#39;, col_common) if len(col_name1 - col_common) != 0: logger.info(f\u0026#39;[{self.check_type.upper()}.QA]{self.sql_1.SQL_DB}.{table}独有的列: {col_name1 - col_common}\u0026#39;) if len(col_name2 - col_common) != 0: logger.info( f\u0026#39;[{self.check_type.upper()}.PROD].{self.sql_2.SQL_DB}.{table}独有的列: {col_name2 - col_common}\u0026#39;) for _col_name in col_common: c1 = find_item(_col_name, columns1) c2 = find_item(_col_name, columns2) logger.debug(f\u0026#39;{c1} -- {c2}\u0026#39;) if c1 == c2: continue logger.debug(\u0026#39;差异的列属性\u0026#39;) # db.table [Field] 字段差异: (差异字段) \u0026lt;差异属性值QA\u0026gt; - \u0026lt;差异属性值PROD\u0026gt;, \u0026lt;差异属性值QA\u0026gt; - \u0026lt;差异属性值PROD\u0026gt; ... diff_fields = ( f\u0026#39;({key})\u0026lt;{str(field1)}\u0026gt;-\u0026lt;{str(field2)}\u0026gt;\u0026#39; for key, field1, field2 in zip_dict(c1, c2) if field1 != field2 # TODO 如有需要 后期此处判断可以使用方法做复杂校验 ) logger.info(f\u0026#39;[{self.check_type.upper()}]{self.sql_2.SQL_DB}.{table} [{_col_name}] 字段差异: %s\u0026#39;, \u0026#39;, \u0026#39;.join(diff_fields)) def create_sql(info, test=False): def _add_host(name: str): if name[0] in map(str, {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}): return name if name.endswith(\u0026#39;.com\u0026#39;): return name # return name return name + \u0026#39;.cloud.wal-mart.com\u0026#39; db_qa = info[1] db_prod = info[8] if info[8] else info[1] if info[0].lower() == \u0026#39;mysql\u0026#39;: qa = MySqlAPI(host=_add_host(info[2]), port=3306, user=info[3], password=info[4], db=db_qa, ) prod = MySqlAPI(host=_add_host(info[5]), port=3306, user=info[6], password=info[7], db=db_prod, ) elif info[0].lower() == \u0026#39;sqlserver\u0026#39;: qa = MsSqlAPI(host=_add_host(info[2]), port=14481, user=info[3], password=info[4], db=db_qa, ) prod = MsSqlAPI(host=_add_host(info[5]), port=14481, user=info[6], password=info[7], db=db_prod, ) else: raise ValueError(f\u0026#39;值错误: %s\u0026#39;, info) qa.zone, prod.zone = \u0026#39;qa\u0026#39;, \u0026#39;prod\u0026#39; if test: qa.tables_name(), prod.tables_name() return qa, prod def main(config_file: str): \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; map_ = { \u0026#39;mysql\u0026#39;: [\u0026#39;Field\u0026#39;, \u0026#39;Type\u0026#39;, \u0026#39;Key\u0026#39;, \u0026#39;Default\u0026#39;, \u0026#39;Extra\u0026#39;], \u0026#39;sqlserver\u0026#39;: [ \u0026#39;TABLE_OWNER\u0026#39;, \u0026#39;TABLE_NAME\u0026#39;, \u0026#39;COLUMN_NAME\u0026#39;, \u0026#39;TYPE_NAME\u0026#39;, \u0026#39;PRECISION\u0026#39;, \u0026#39;LENGTH\u0026#39;, \u0026#39;SCALE\u0026#39;, \u0026#39;RADIX\u0026#39;, \u0026#39;NULLABLE\u0026#39;, \u0026#39;COLUMN_DEF\u0026#39;, \u0026#39;SQL_DATA_TYPE\u0026#39;, \u0026#39;SS_DATA_TYPE\u0026#39; ] } for line in csv.reader(open(config_file, encoding=\u0026#39;gbk\u0026#39;)): if line[0] == \u0026#39;\u0026#39;: break if line[0].lower() in {\u0026#39;数据库类型\u0026#39;, } or line[0][-1] == \u0026#39;-\u0026#39;: logger.info(f\u0026#39;skip -- [{line[0].upper()}]{line[1]}\u0026#39;) continue if line[1] not in [\u0026#39;d_sam_logistics\u0026#39;]: # logger.info(\u0026#39;skip %s\u0026#39;, line[1]) continue if line[2] == \u0026#39;\u0026#39;: logger.info(f\u0026#39;=== Waring: (DB HOST Not Find [{line[0].upper()}]{line[1]})\u0026#39;) continue try: ContrastSQL(*create_sql(line), map_) # create_sql(line, test=True) print(f\u0026#39;{line[1]} Success \u0026#39;) except Exception as _e: logger.warning(\u0026#39;!=\u0026#39; * 20 + f\u0026#34;[{line[0].upper()}]{line[1]} Error\u0026#34; + \u0026#39;!=\u0026#39; * 10, ) logger.warning(f\u0026#39;!#!# {_e} !#!#\u0026#39;) logger.warning(\u0026#39;!=\u0026#39; * 20 + f\u0026#34;[{line[0].upper()}]{line[1]} Error\u0026#34; + \u0026#39;!=\u0026#39; * 10, ) if __name__ == \u0026#39;__main__\u0026#39;: logging.basicConfig(level=\u0026#39;DEBUG\u0026#39;) logger.setLevel(\u0026#39;INFO\u0026#39;) file = logging.FileHandler(\u0026#39;sql-2.log\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf8\u0026#39;) file.setLevel(\u0026#39;INFO\u0026#39;) logging.getLogger().addHandler(file) logger.info(time.strftime(\u0026#39;=== Start Time %x %X\u0026#39;)) pa = r\u0026#39;C:\\Users\\vn54lnb\\Desktop\\WMT\\bcdr_prod_qa_sql.csv\u0026#39; main(pa) logger.info(time.strftime(\u0026#39;=== End Time %x %X\u0026#39;)) ","date":"2022-11-17T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94%E5%B0%8F%E5%B7%A5%E5%85%B7/","title":"数据库表结构对比小工具"},{"content":"esxi snmp 配置 esxi 详细文档设置VMware vSphere 文档\n开启 snmp 1 2 esxcli system snmp set --communities public,private esxcli system snmp set --enable true 配置轮询的 SNMP 代理 1 esxcli system snmp set --port 1600 ","date":"2022-10-29T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/yujunshu-2/","title":"esxi snmp 配置"},{"content":" 自序：\n给世界别一个我\n浩：\n这是你于二十五岁的盛夏，于午间十五时零九分动笔写的信，天气灰蒙蒙的，城市像是披了一层保护色，你此时的心情，有点小忧伤，但无关痛痒，时光如沙，渐渐滴落，有一种忆，叫做最美。就像唐顿庄园里写的一样：The business of life is the acquisition of memories.In the end that's all there is. (人生就是不断收集回忆的过程，最终能陪伴我们的也只有回忆了。)那么长话短说，就像以前那样，诉说你的过往时年，可否乐意？ (其实不管乐意与否我还是还说。)\n当然先从爱情这个话题说起 山有木兮木有枝，心悦君兮君不知。\n在关于爱的故事里，你最爱听矢志不渝；在所有的婚姻里，你最爱的是忠贞不移。\n很年轻的时候你谈起恋爱就奋不顾身、飞蛾扑火，后来烧退了、梦醒了。之后不是没有遇到更好的，只是温度没那么简单传到心里面了。你也知道两个人终归比一个人温暖，但你还是在等。你说那人出现时，你的温度就会从心里传来，你不怕发烧，因为对方和你一样。这种感觉让你安心，就像万家灯火、漫天星星和稻田里的萤火虫。你是知道的嘛，少年时光，最美不过喜欢。\n但经过了那段飞蛾扑火的爱情，让你对爱情有些害怕，你总是认真且怂，不敢告诉那个你在大一就喜欢的姑娘，喜欢她，所以你一直在积攒，积攒你对她的喜欢，总是制造一些“偶遇”，让你出现在她的生活中，其实爱情里没有偶然，只有必然。就像那个夏天，她问你，我们的未来会是怎样？她闭上眼睛。。。然后你闭上眼晴，也看不到自己，但你能看到她。再之后，她问你，你喜欢的是谁啊？你只是不说话，微笑，眼睛里看到的，全是她。但你还是怂，不敢说你出对她的喜欢，经过一年的沉淀，你发现你对她的喜欢日益加深，终于在十月初，在她逼问你将近两个小时的情况下，你终于说出了对她的喜欢，你满怀期待，忐忑不安，期待着她的答案，可是过了两天，你发现，她以为你只是开玩笑（其实那时候你已经知道了结果)，你不甘心，于是你继续作死，你给她发了喜欢她的“前因后果”，你还是有对于希望的忠于，但是她的第一句回复就让你知道这是一场意外（我想我们以后连朋友都做不成了)，而她拒绝你的理由，就是你不够勇敢，她喜欢那种“直抒胸臆”的，是啊，你对爱情的态度就是认真且怂，你总是在想，如果早一点，能在她情窦初开的时候于她相遇，哪怕是相遇不相识都好，让你做一个经过她身边的人，一个只有一面之缘，却因她心花怒放的人。你对爱情的完整态度就是 —— 认真且怂，从一而终。\n后来明白，其实所有喜欢，就算没有在一起，也没有关系,因为,你也会喜欢那个因为喜欢她而闪闪发光的自己，世界上多得是爱而不得和亲爱的陌生人，而这世上也多得是温柔待你和笑靥如花的人，所以，把这份喜欢悄悄的放在心底就好。\n最后，你写下这样一句话一一即使是没有结果的爱，命中注定没有未来，是个劫数也罢，也甘愿。仍感激你。是你，让这爱绽于心上。只是，此后安稳岁月，不再提及。自此，相忘于江湖。\n风 你要去哪里啊 偷偷吻过她脸颊的事你忘记了吗 她 还一直在等你啊 用最美好的年华来诉尽衷肠 你说你是风 顷刻间便不见踪影 后来 你不知道的是 她变成了云 每一个风吹过的地方 都有她的足迹 而伴了她一生的 便是雨 “时间的跨度不过是一次遇见和告别，​而我不敢往时间里，再看一眼。”\n在那即将步入大四的假期，那个时候街上到处放着陈雪凝的《绿色》，天气有些闷闷热，少年和少女的初次见面就在白马湖的入口，沿着河畔一路向前，少年和少女毕竟是第一次见面，大抵是沉默的，就像《门前》诗里一样“草在结它的种子，风在摇它的叶子，我们站着，不说话，就十分美好。”就这样一路走到大小河街，天色渐渐暗了下来，蝉声落下，蛙声响起。风徐徐吹过耳旁，就这样，故事开始了。\n就再往时光的夹缝里偷偷看一眼吧，那时候，蚊子分外嚣张，天气闷热闷热的却也不愿意把牵着的手分开，白马湖的街道好似没有尽头，石桥下的温存，回宿舍时公放着的《山楂树之恋》，或者是边走边写诗念给少女听的少年，一起看的《隐形守护者》，少年说着心里的忧虑，少女安静的听着，静静的治愈着少年，还有那时候总会买一瓶酸奶给少女的少年，原来那时候的晚风，都很温柔。\n有些故事终究是没有结尾的，就像日落时轻轻发出的那声叹息啊，时光都不忍惊叹盛夏的那声呓语。\n就像离开那天，睡莲羞哒哒的藏在莲叶里张望点水的蜻蜓，蜻蜓也不说话，只是用双翼轻拂风的脸颊，风也不说话，只是满含笑意地看着云朵，云朵也不说话，只是安静地望着那片蔚蓝的天空，天空也不说话，只是映照阳光下的少年，少年也不说话，只是默默看着时光深处的少女，少女也不说话……\n只是最后那声再见不为任何人。\n那个盛夏，只是还没来得及好好道别，就被风吹向别离。风来过的，只是吹了一阵，就只余盛夏时轻轻发出的一声叹息，少年总觉得是有亏欠的，抱歉，那时候的少年在四面都是墙的空间里，罢了，罢了，已是黄昏独自愁，更着风和雨。是啊，有些人，只见过一面，余下的只剩告别了。但那一面，也惊艳过少年的时光，莫听穿林打叶声，何妨吟啸且徐行。少女，向前看吧，海子曾说：你来人间一趟，你得看看太阳，和你的心上人，一起走在街上。就像今天，落霞打翻了一盏残阳，流质的云霞漫遍西天，带着耳机听歌的少年，漫步在林间小路，想着世间晴朗，万物可爱。对啊，风来过的，炙热的，温暖的，怅然的…可是风总是要走的啊，既然留不住，不如让风把思念带走吧。\n最后，少年这下这样一句话——我们这一生会遇见多少人，缘份如这露珠一般，朝生暮死，惊艳一刹。那些在生命中留下惊鸿一瞥的人们，此后山高水远，各自珍重。\n风曾听过 一片落叶的思念 一朵梨花的哀怨 一场盛夏的相遇 所有故事的开始 美得冒泡 所有故事的结束 悲的像狗 细细品尝 人情冷暖 世态炎凉 红尘漫漫 滚滚心事 唯自己懂 心里的那个人 长得好像你 从里到外无一不合我心意 追逐着稻田的小老鼠，三两声说着入冬的故事，晚秋的风吹着河岸，梧桐的落叶轻吻桂花的脸颊，男孩把晚风藏进思念里，去到那个丁香花似的女孩。\n总归是两个孤独的灵魂，于这冬日相逢，“在时间的无涯的荒野里，没有早一步，也没有晚一步，刚巧赶上了。”那时候的男孩刚经历了一场重大的、不可言喻的痛苦，而女孩则是抑郁不前的。幸运的人总是相似的，而不幸的人是会相互吸引的，那些温柔的话语，感动的瞬间，心慢慢靠近，就像男孩诗里写的：\n路边偶遇一朵野山茶花 在等着春天 会盛开的 带着泥土的芬芳 纯净 美好 静静望着对面那颗梨树 沉默 骄傲 根深深扎进土里 痴情 蓬勃 我相信的 一直相信 总有会盛开的那天 花香四溢 沁人心脾 他们再次相遇的那天，男孩仍记得回去的时候，火车站外打了一层厚厚的霜，寒风刺骨也冷清，女孩独自站在接应口等着，四个小时的等待，女孩的手脚已经冰凉，却仍望着站口，男孩因为核酸的缘故焦急的等待着结果，结果下来之后马不停蹄的赶向车站口，快步走向冻到发抖的女孩，两个孤寂的灵魂，慢慢靠在一起。\n他们在一起了，没有海誓山盟，亦没有相互将就，只是平平淡淡的从雪中走过，是啊！此间长情。女孩对男孩说：“我们都是暗淡的人，却在彼此的交集里发现了光。”男孩回道：“清晨，朝露，林荫，晚霞，黄昏，与你。”是啊，此间情长。\n他们热恋了，一起吃饭，一起逛商场，一起说着生活里的趣事，一起吐槽着工作的无趣，只是雪不在下了，万物开始复苏，积雪开始融化。陪伴就是最长情的告白，男孩是这样想的。\n他们不在一起了，是啊，终究陪伴只是陪伴，解决不了问题的根本，女孩依旧是处在抑郁的环境里，男孩无力改变这些，虽然男孩也曾想陪女孩走出这样的环境里，可女孩终究是没能走出来，最后，女孩终究是对男孩说了：我们不能在这样下去了，我们分开吧。男孩心里一千个一万个不愿意，话到口边却是同意了分开，因为男孩知道自己没办法改变女孩，终究是不合适的两个人，只是在冬夜里看了一场雪，同淋了一场雨，就要各自回到自己的生活里了。那天的风很平静，却吹不散些许离愁，天气格外的热，男孩却不肯归去，漫步在铺满回忆的小路上，丁香花盈盈撒撒，远处传来歌声“谁家的姑娘有着黝黑黝黑的眼”嗓音沙哑，却又动人心弦，夜色正朦胧，男孩仍不肯归去，抓着记忆残留的影子，细数那些弥留的温柔。\n河对岸吹来一阵风 风吹到岸边 岸那边 伫立着一个你（女孩） 最后，男孩写下这样一句话——故事的开头总是极具温柔的，夏至的风、立秋的雨，泪花点缀在微笑的离别上。无妨，无妨，飞蛾也曾扑过那火，尽情燃烧的岁月，倾尽一生，不过是大梦一场，也罢，最炙热的季节，却承载着最盛大的别离。故事的结尾也极具温柔，立春的暖，冬至的寒，悲喜藏在欢愉的回忆里。\n我把世俗一饮而尽 却不知何时泪挂在眼角 我知 我念 我痛 就这样抓着一大把回忆 徒劳的 我有幸伴你过寒冬 还路过暖春 向着夏至 你怎还低着头 向南走 我撞破南山 去到云那边 你转身微笑着 轻轻的向茫然的我挥挥手 从此晚风不再温柔 男孩再无春去 亦无秋来 六年时光过去，爱情不过是往这汪洋大海里投了一块石子，只是泛了些波澜，日子便又归于平静，是啊，爱情不是生活的全部，那生活还有什么呢？当然还有自我，就比如如今的我仍然感谢那些在岁月里惊艳过我的人儿，让我成为自己的光，吸引力法则告诉我们，你要成为爱的磁铁，是啊，泰戈尔说过：不是我选择那最好的，是那最好的选择我。如今仍心怀感激，毕竟，教会我如何去爱，如何去被爱。最后，写下这样一句话：那些曾在心底里待过一段时间的人儿，就好像时光酿的一坛烈酒，沉醉了回忆，亦清醒了人生。不曾言语的爱恋，就让风把它吹向过往吧。值得怀念吧，毕竟啊，攒了多少个夕阳以及朝露。\n自上而下的雨滴 落在光滑的镜面上 日子过得倒也清闲 逐渐了然 风为何带走温柔 一定是藏了太多想念了吧 雨为何埋着哀怨 一定是说了太多誓言了吧 油纸伞下的泥泞 那些惊艳了时光的倒影 汇聚成七色的云烟 雨声停了 我们都要成为光呀 不只是照在一个人的心上 而是要打败那些心底里的小小怪兽 远方有梦 梦还很长 接下来，便是自我这个话题，竟然是关于自我，便用你的视角来写这一段过往吧。\n六年的时光揉碎成影，撒在每一条名为青春的路上。这么些年，你的性格渐渐趋于平和，讲到自我，就得说说上文中那场重大的、不可言喻的痛苦吧。\n你知道你生病了，病了好些年了，在与君书（一）里就提到过的，每到雨天，就会有一种深入骨髓的冷，那是抑郁症的生理反应，后来身边的人让你感到温暖，病情也有所缓解，生理上的反应也渐渐消失，便又觉得这人间可贵。\n直到疫情开始的时候，二零年初，学业和生活的双重压力之下，病情加重了。\n二月十三号\n“我生病了”“走饭，等我醒来就带我走好吗？算我求你。”（走饭因为抑郁症而离开的世间）\n仍记得走饭的最后一条微博“我有抑郁症，所以就去死一死，没什么重要的原因，大家不必在意我的离开，拜拜啦。”那样鲜活的生命，就永远定格在了12年3月17号的凌晨。\n同是二月十三号这天你写下“下辈子做牛做马，实在不行做头猪。”\n因为你不愿意再做一次人，活在这世上。\n还是在这一天，你写下“就像一条无人问津的小路，雨水冲刷了所有痕迹，于是就变成了泥土中的任意一员，又像是万千尘埃中的一粒，也曾随风起舞，可最终还是归于平静。”\n你活在一个四面都是墙的环境里，看不见光，眼底里尽是灰色，只剩沉默，也只有沉默。\n二月十四号\n“身体它好像有自己的想法了！”\n生理上的苦痛使你精神上越发振奋。\n二月十五号\n“你得争气，你得对得起我们……没事，快结束了，这场梦。”\n就好像做了一场梦，生不带来死不带去的，只是想快点醒来，却怎么也醒不过来。\n二月十六号\n“雪莉的世界不欢迎任何鲜活的生命。”\n那个笑靥如花的姑娘就永远停留在了25岁。你觉得并不沉重，只是觉得惋惜。毕竟你也同是鲜活的生命之一。\n二月十七号\n“没有人发现我抑郁了，他们只是觉得我变懒了，不爱动，不爱说话，不爱吃饭了，只有我自己察觉到自己好痛苦，好痛苦。”\n一个星期说的字数不超过10个字，那么外向的你在所有人眼里是这么的“内向”。\n“我一直在撒谎，但他们不知道的是，我一旦不撒谎了，我就真的再也不撒谎了。”\n一直骗自己骗说我很好，很好。就是比较“内向”。\n“要是上天再给我一次选择的话，我不想活着——甚至活过。”\n已经流不出一滴眼泪了，你甚至想回到二十多年前杀死那个才出生的自己。\n“我怎么就变成了小时候最讨厌的自己呢 甚是厌恶 对了 我只是轻视了自己并未轻视生命。”\n生命仍然可贵，只是你自己觉得可以对自己的生命做出决断罢了。\n二月十八号\n“我愿化为尘埃 而后 渐渐消失不见”\n生命不过就只是一刹那，像毛不易歌里写的“一生太短，一瞬好长”一样，做这消弭于世间的尘埃也不错。\n二月十九号\n“他们又开始和我谈未来了，要死要活也不管我，要活我不知道，去死是肯定的。”\n“基督教徒不允许自杀，我就笑笑不说话。”\n人生来就是被束缚着的，不论是谁都逃脱不了。\n二月二十二号\n“每天早上我都在想该怎么去死好些。”\n跳楼死相太难看，服毒肚子会很疼，吃一瓶安眠药也只是涨肚子，根本死不了。\n二月二十四号\n“啥时候可以飞翔呢？”\n还是会向往天空，从高处往下跳就像飞起来了一样。\n二月二十六号\n“昨夜梦里开了个批斗大会，很荣幸的是，我是主角。”\n二月二十八号\n“世间为何如此这般，如此这般。”\n沉默中也爆发不了，只能在沉默中消亡。顿时感觉很对不起鲁迅先生。\n“我要若无其事的装作饭菜很好吃的样子，其实每一口我都想吐。”\n生理上的反应越发严重。\n二月二十九号\n“最后那声再见不为任何人。”\n也不需要为了什么人，就只是为了自己说一说的吧\n三月二号\n“带上安全帽之后就在想从楼上跳下去恐怕不会死吧，八成是高位截肢。”\n已经决定如何离开了，真好。\n“我不愿意为自己而活，所以我选择去死。”\n三月三号\n“抑郁是爱的附属品。”\n他们是你最亲近的人，同时也把刀子捅进了你心里。\n三月七号\n“我难过的快要化掉了。”\n“真羡慕那些意外死亡的人，啊，不对，这样是很不尊重那些意外死亡的人，所以换一种表达，真希望我能成为意外死亡的人。”\n像死神来了里面一样，咋样也逃脱不了的死亡可太奇妙了。\n三月八号\n“微风吹过，杏花开了。”\n等之后离开，希望能用杏花来记念就好。\n“不是我们自愿来到这个世间的，又为何在来到之后，就一定要背负什么呢？”\n如果可以选择，宁愿不要来这世间。\n三月九号\n“埋怨，责骂，暴力…”\n“语言是有温度的。”\n那温度让人觉得很刺骨，甚至想逃离。\n三月十号\n“生存还是死亡。这不是问题。”\n但选择题变成只有一个答案的单选题之后，闭着眼睛都能答对！\n三月十三号\n“我们有权利活着，就像我们有权利去死一样。”\n这是外界无法干预的，绝绝对对的由自我去选择。\n三月十六号\n“你生命的最后一天你会做什么？\n很多有回答说好好玩耍一整天\n也有回答说要陪家人好好呆一整天\n也有做自己想做却从未敢做的事\n诸如此类。。。大多是很美好的一天\n我就比较厉害了\n我回答说\n去死。\n倒也一点问题也没有”\n三月十九号\n“希望不要有下辈子了。”\n“人总有一死，或今天或明天，实在不行大后天。”\n三月二十号\n“我不知道怎么了，上厕所全是血。”\n“一直干呕，我快忍不下去了啊，老天你有种弄死我，然后我还要谢谢你。”\n“干呕完胃就抽痛，抽痛完继续干呕，真棒！”\n生理上的反应越来越严重，舍曲林片吃下去是苦的，心却是甜的。\n至此，你已经决定要在五月离开了，你把签名改成走饭的话“好像明天就要流浪去远方”， 你选好了时间，地点，你独自前往。甚至于遗书你都写好了，我仍记得你遗书里有这么一句话“我对不起所有人，除 了自己。”\n五月二十二号\n你站在二十层的废弃天台上，明明那么恐高的人却向下望着。\n“不害怕吗？”\n“当然害怕啊。”\n“那为什么还要往下跳。”\n“因为不想活着。”\n左脚迈上围栏上，这时后面突然有个人把你死死抱住。\n“你是谁啊？”\n“小伙子，没什么过不去的，快下来。”\n“你放开我。”深呼吸了两口气\n“我不放！”\n就这样，你被一个六十多岁的老大爷紧紧抱住，可能是去死的念头花光了你所有气力，以至于你竟然挣脱不开。\n当时是晚上十点半左右，天色早已灰暗，你特意选在这个时间路上都没什么行人选择在这样一个偏僻的地方离开，却没想到竟然还有这样的一个人，尾随了你一路。可能是你净想着怎么去死了，以至于都没发现后面的人。\n“你累不累？你放开。”\n“不放，除非你答应我你不跳了才行。”\n“你放开，我都没力气了，还咋跳。”\n“小伙子，我给你说，没什么事是过不去的，想开一点，想想家里人，想想…”\n后来你的大脑一片空白，后面老大爷一个劲的嘀咕着，就是不把手松开，然后你就气笑了。\n“你快放开，我不跳了。”\n然而老大爷一点放开的意思都没有，硬生生拖着你往后拉。你已经无力去反抗了，只能任由他拖着，拖到楼梯口，老大爷才放一只手，另一只手还抓着你的手臂，生怕你再往回跑。就这样一路走下楼梯。\n“你是不是跟了我一路？”\n“小伙子，我买完菜就看见你不对劲，你说你一个人跑这么荒僻的地方干啥，我不放心，就一路跟着来了，你就像丢了魂儿一样。”\n“行了，我不跳了，你回去吧，老大爷。”\n“唉，就是我的菜不知道扔哪儿去了，算了，你赶紧打车回家去吧，我看着你上车。”\n回到宿舍，看到那盆多肉，本来奄奄一息的它， 竟然活过来了，曾以为它注定会在这个夏天离开的，带着那份毅然决然的死亡，它生病好久啦，叶子也渐渐泛黄了，可能它也曾想过就这么一了百了吧，却没想到它要开花了，想起那时候，它只是需要一点点水就可以活过来了，可它知道，只有自己可以补给自己，它把所有体内的水分榨干，想换一个未来，可能是天见犹怜，它终究挺过那个夏天了，并且要开出花来。\n最后，你写下这样一句话—— 太宰治说:我本想这个冬日就死去的，可最近拿到一套鼠灰色细条纹的麻质和服，是适合夏天穿的和服，所以我还是先活到夏天吧。\n你看，生命如此容易满足，我仍记得去年的这个时候，想救一只垂死挣扎的鸟儿，最后只余下一滴眼泪，你尽力了啊，一个想去死的人\n一定是因为活的太过认真。\n“你要笑啊！”\n“好的。”\n风儿啊 你能听一听我的思念吗 那找不到出路的一腔孤勇 你能听一听吗 如若不能 那你就把他埋葬了吧 顺带着连我的心 一起 葬了吧 雨儿啊 你能说一说我的过往吗 那个布满伤痛的单薄少年 你能说一说吗 如若不能 那你就把他埋葬了吧 顺带着连这副躯壳 一起 葬了吧 雷儿啊 你能看一看我的归途吗 那布满荆棘却又看不见尽头的路 你能看一看吗 如若不能 那你就把他埋葬了吧 顺带着连我的灵魂 一起 葬了吧 光儿啊 我已经没有什么可以给你的了 那便把我所有骨子里刻着的 心底里印着的 也一并 葬了吧 然而抑郁症并不像感冒了吃药就会好，发烧了打针就会好，我只是短暂的逃离了那个地方（四面都是灰色的墙），然而毕业之后我仍要回到那个环境。只是撒了一点月光的墙，又渐渐被黑暗吞没。\n五月三十一号\n“我是孤独。”\n六月三号\n“我的骨子里弥漫着悲伤。”\n六月九号\n“不言语。”\n六月十二号\n“相遇和离别就在一天，生与死之间只隔了一刹那。”\n六月十四号\n“我的记忆力在慢慢衰退，好多事情过了一两天我就不记得了，就像快递今天到了，我后天才想起来我有快递。”\n六月十七号\n“一个人的细水长流，一个人的浮世清欢。”\n六月二十号\n“我就像个哑巴，他们还要我巴拉巴拉…”\n六月二十一号\n“如果有另一种可能，我不愿做我，甚至我不愿意做任何人。”\n六月二十三号\n“今天小侄子问我：叔叔我感觉你好久都不开心，你能不能开心一点。我顿时惊觉，甚至觉得有泪在即。古人诚不欺我，小孩子看待事物果然是透过现象看本质的。”\n六月二十五号\n“越亲近的人往往越刻薄，而我就不是，我宽宏大量，甚至可以说我的肚子里有一艘船。”\n六月二十七\n“今天去找工作了，他们竟然说我讲的很不错，我惊讶了，我竟然说了这么多话，果然，面对孩子我还是能说一些话的。”\n六月三十号\n“我又去面试了一家，他们说我的字丑，但他们还是同意让我实习，难不成是因为太缺人了？”\n七月一号\n“今天他们批评以及埋怨了我一整天，突然没啥想说的了，也没啥想写的了”\n七月二号\n“今天和父亲“大吵一架”，当然，我都是抽自己，我和父亲都哭了，本来我没哭，直到父亲哭了我才哭了，就觉得世界安静了，我不想再说任何一句话了。”\n七月三号\n“不曾言语，不曾喜恶（wu）”\n至此，你离开了那个地方，或者说你逃离了那个四面都是灰色的墙的环境，说实话，不是什么大动干戈的心事了，按照医生说的，按时吃药，转换心情，一切都会好的。\n曾经我也想过一了百了，因为心早就被掏空，不能被填满，因为我仍渴望活着；曾经我也想过一了百了，因为那松开的鞋带，我无法好好将它系紧，如同不懂得系紧这相处的关系一般；曾经我也想过一了百了，因为那天独自盛开的杏花，它一定是那么努力的活着才能盛开啊。\n伤疤都留给回忆吧，放下才能得到更好啊，抑郁症不是什么可以让人惊叹的事，同时也不是什么让人异目的事，就仅仅是生理上的病，没什么好同情以及怜悯的。\n最后，你写下这样一句话：我曾也是死于一场患难的孤独者，也没什么好拍案叫绝的波澜，仅仅是一面灰色的墙，撒了一点月光，就照亮了一个盛夏，感谢那些，愿意撒一点月光的人儿，至此，生活慢慢归于平静，没有什么好掀起心绪的故事了。\n踟蹰着 步履蹒跚着 像是黄昏最后的那抹夕阳 彳亍着 细水长流着 像是树荫后的那一片荒草 徐徐着 姗姗来迟着 像是初冬后的一瞬暖阳 那斜阳下的翅影 被时间拉长的影子 不曾言语 不曾喜恶 风吹过来了，我们都要做更好的自己啊。\n然而生活中不仅仅只是背光的那一面，也有向光的那一面呀。就像那天去的福利院，然后你发现身体上的残缺往往心灵更美，他们的眼睛没有一丝杂质，笑起来的样子是你见过最美的天使，有看起来凶凶的实际上连最后一个打扫卫生的他都不忘喊他上去休息的大家伙，也有不会说话但却笑的好纯好纯的小可爱……就在回来的路上，司机问你们去那（福利院）干嘛？前排的一个小学弟说社团组织活动，我们去玩。然而你心里想的是：我是去看最美的天使，都是这辈子折了翼的，却努力飞行的小天使，愿以后的日子我能看见他们张开双翼，带着最美的笑容，向天边飞去。\n是啊，那个时候的你向往着生活，说来也有些好笑，你开始看小红书，精心挑选搭配，用着不知是哪儿的偏方，用白醋、食盐、水（比例3：1：9）来洗脸从而变白，哈哈，后来你果真变白了，不知是真的有用还是心理作用。很多朋友问你近来怎么发生了这么大的改变，其实没什么大的改变，只是成为了更喜欢的自己，对，这么中二的话你甚至想要大声对身边所有人说出来，现在我都替你尴尬！不过那个时候的你是真的精致的，洗面奶、爽肤水、面膜、精华液…除了没有化妆你甚至想往脸上贴一层保护膜，当然，不仅如此，你开始“花里胡哨”的搭配各种颜色的衣服，绿色、米奇色、浅蓝、淡红，甚至粉色你也没放过… 你还写下其实我也只是突然不想让自己再糙下去了，并没有因为某件事或者某个人而去改变自己，精致只是一种生活品质，希望大家都可以有一个属于自己的“精致”，只要自己觉得开心，那做就对了。哈哈哈，那个时候你甚至还配上了头发长到睫毛的自拍！如此之中二，如此之神经，让我抠出三室一厅。\n当然，文字始终陪伴着你，就像那天你写下：愿你历尽千帆，归来仍是少年，喜欢的事就去做吧，喜欢的人就去表白吧，这青葱岁月，不干一两件让自己疯狂的事，那又有什么意义呢，趁我们还年轻，趁时光还未老。\n或者是：人间四月，暖到落泪。\n亦或者是：其实所有喜欢，就算没有在一起，也没有关系,因为,你也会喜欢那个因为喜欢他而闪闪发光的自己，世界上多得是爱而不得和亲爱的陌生人，还请善待自己，而这世上也多得是温柔待你和一见你就笑的人，所以，把这份喜欢悄悄的放在心底就好。\n你看，日子可以如此简单且充裕，生活也可以如此诗意且浪漫。最后，你写下这样一句话：我去到过黑夜，也曾见过暖阳，喝过一碗炙热醇厚的烈酒，也品过一杯热香扑鼻的浓茶，也见到梧桐的枯叶吹向远方，是啊，生命就是这样一半荒芜，一半盛放。\n逝去的青春 偷偷听清风 私语 泪花绽放出笑的眼角 岁月的嘎吱作响 徘徊不去 最是那一低头的温柔 心如止水 泛起波澜 被时光温撒的岁月 清晨朝露 午间绿茵 傍晚霞光 一壶酒 闲说过往离愁 一杯茶 淡品岁月清香 一故人 轻言世间温柔 徐徐 六月末暖阳的微笑 的震颤里 我在等风 六年的时间见惯了多少离别，而如今日子过得还好，有几滴清酒般的故人之谊，有几曲骊歌般的殷切思念，来人照我笑靥，去者不引我悲伤，复有何求。\n接下来便是离别这个话题 这是一场平静且孤独的离别。\n就让时间回到那个十八岁的年华，背上行囊，总觉得外面的世界很新奇，一个人的旅途，七十个小时的火车，一路向南。那时候的少年还带着倔强的模样，认为这世间不过是一场凉薄的戏剧，甚至觉得没有什么能使少年停留，少年像个不系之舟一般，横冲直撞的、野蛮生长的放肆青春。（后来少年才知道，有人为我们沏了一碗感情深致的浓茶，我们却总说来日方长，于是将茶碗搁置，待花间一游再回，或他处小酌而归，以为它依旧会热香扑鼻等在那里，殊不知在这世上回首之间，便是人走茶凉。 因此要记得，感情这碗茶，一定要趁热喝。）\n每个离别的日子，都在下雨。那天的雨很静谧，带着些许不舍，不愿回头，少年想证明他是一个独立的且能够照顾好自己的个体。那个时候少年心里想着：曾经在心底里住过的故事，今天就让它告别吧，有一天你终会对那些在你生命里住过又离开的人提不起一丝恨意。总有一天我一定会忘记我什么时候遇见的你们，但还好告别前我们都在岁月的尽头互相张望过。如今的我终于可以确信，我来到这个城市，也许就是为了遇见你们；而我遇见你们的全部意义，就是为了与你们告别。再见，伊宁；再见，故人。\n于是就这样，少年转过身，没有看见父亲的那滴眼泪以及鬓角的那根白发。少年终是大步的往前走了，毕竟远方有梦，亦有诗。\n到达的那天，夜色朦胧，清风徐徐送过少年的脸颊，坐着10块的摩托车赶往校园（想来有些好笑，出租车的费用也是10块，你就这样被骗了，还美其名曰为了兜风），就这样 \u0026hellip;\u0026hellip;\n四年一晃而过。\n那是日落时轻轻发出的叹息啊，这一叹，匆匆四年过去了，总感觉还是当初那个在台上自我介绍时腼腆的少年，那个说着“亚克西”的少年，大学好似只有三年，真的还来不及好好道别，就已经匆匆说了再见，最舍不得莫过于349的小伙伴，以及小虎和新辉，还是要道一句感谢，谢谢小三班的同学，让少年有了这一段旅程，唯一的遗憾就是还没有和他们一起拍毕业照，想起当年，总觉得来日方长…来日方长，却只剩来日，没了方长，总觉得有千言万语…千言万语，却只剩一声珍重，那就祝福吧，愿小三班的各位前程似锦，今后有良人相伴，在尘世获得辛福。希望以后相见，能轻轻说一句:好久不见，三告。此后，山高水远，万事胜意。\n离开的那天，枫叶落在木制色香的长椅上，石板路上谁曾来过？那些诗篇、那些柳絮、那些零零碎碎，猛然惊觉“花开的那一天，天青色等烟雨，雨渐渐大到我看你不见”那些都是周杰伦的歌啊。不，那不是…那是……我的整个青春。纯白色的帆布鞋，只戴一边的黑色耳机，落雨时狂奔的傻子，总幻想逃课去花落的地方，把所有热情都藏进天青色的烟雨里，方便面的调料总要舔的干干净净，明明只有一包辣条可香味传的满间教室都是，当然还有总是不及格的考卷。\n……\n都过去了呀，都过去了…枫叶落在石板路上，木制色香的长椅空无一人，操场上的歌还继续唱着，原来……是一场梦啊。\n最后，你写下这样一句话：总有些惊奇的际遇，或者说，是每一个在黑夜中撒下了一点月光的人，借着这点月光，就这样拼凑出一个我。或许也不完美，但所见即是我，我自认也算半个有趣的人。 此致，万事胜意。\n风在等我 震颤里的 微笑的六月末暖阳 徐徐 温柔世间轻言 人一故 清香岁月淡品 茶一杯 离愁过往闲说 酒一壶 霞光傍晚 绿茵午间 朝露清晨 岁月 被时光温撒的 波澜泛起 止水如心 温柔的 最是那一低头 不去 徘徊 嘎吱作响的岁月 眼角的泪花绽放出笑 私语 清风偷偷听 青春的逝去 这是一场无声且浪漫的告别 这一场：浩，就用你的回忆来说吧。\n听到蝉鸣，看到蚂蚁搬家，果然下了些雨，风有些大，戈壁滩上放牧的孩童在驱赶着牛羊，想起很久之前家里养了一头驴，那时总想着有一天可以骑上它去外面的世界转一转，等我从外面的世界回来，它却早已经不在了。是啊，逝者如斯夫，那些淋过的雨，那些愿意为你撑一把伞的人儿，那些沉默的瞬间，那些还没来得及开口的道别，就这样被风吹进回忆里，也许是在某个黄昏，也许是在某个清晨，那些老旧相片，珍藏在玻璃瓶里的回忆，会悄无声息的在脑海里拂过，泛起波澜，也许会叹往事如昨，旧事如尘，又或许纵有千言万语，也只余一声叹息，一句意难平。然而朝暮轮转，如今仍要大步向前。\n我总是会梦起，那段教书的时光，孩子们的咿咿呀呀，刚开始的时候，我是极不愿意的，因为本身教生物的我被调度到数学，我怕自己做的不够好，毕竟战前换将是大忌，奈何事出突然，也只能临阵磨枪了。幸而，准备虽不足，但还好有些底子，但也没有出什么大的差错。孩子们的笑容总是纯粹的，当然除了不写作业的时候，而我本着有教无类的想法，不仅仅教他们数学，甚至于还教他们写作，仍记得有个考试作文让他们写《最爱_____》，有些调皮包写的是《最爱钱》，《最爱吃饭、睡觉》，好家伙，什么不相关的名词咔咔往上面写，就是不写正常的，我痛心疾首，边放着《世界美好与你环环相扣》一边一句一句的给他们讲如何运用歌词写到作文里（毕竟当初的我也是这么干的），就比如用“此时已莺飞草长，爱的人正在路上，我知他风雨兼程，途经日暮不赏。”来写《最爱父母》，多好的句子呀，孩子们在一个封闭式管理的学校，父母都只有在周天这一天才能和孩子一起度过，大多数孩子家里都比较艰苦，还有好多父母外出打工供孩子读书，“卖却屋边三亩地，添成窗下一床书。”虽然孩子们大多数学习不好，甚至可以说除了学习其他都会，但我能感受到他们生命的炙热，那种透彻不沾染世俗的眼眸，如今仍难以忘怀。是啊！生命中总有些让人怀念的岁月，就像那天的教师长跑比赛只拿了第三，那些试卷只写了一半，那首歌只唱了一半，虽然遗憾，却如此美好，晚风吹过的时候，就代替我去看看那群孩子们吧，纵然山高水远，却仍希望晚风能把希望撒一点给他们。\n最后，你写下这样一句话：感谢这么久的陪伴，是你们，往这水面投了一颗石子，翻起了那么多的波澜，比后安稳岁月，愿日华似火，照亮你们前程似锦；愿月华似水，温暖你们的过往时年。\n那天有风吹过 于是我们就把回忆放在 每一个寻光的岁月里 或许不是 是放在那浅浅的小河流里 时光静静的淌过 金色的光影拍打蓝色的海岸 画出一条七彩的梦 或许也不是 是放在那湛蓝无边的星空里 流星悄悄的划过 深邃的银河点缀灿烂的星光 许下切切在心的秘密 别哭 风总是会走的 岁月添了些痕迹 足够 别回头 泪珠也要撒在辛勤的汗水上 此后 道阻且长 愿君珍重 这是一场沉重且哀莫的离别\n在此之前的三告还未亲身经历过仍何一场生离死别。那个时候，总觉得死亡是那么遥不可及，虽然也曾向往过死亡，但一切来的是那么突然，二一年十月二十一号的那个夜晚，突然接到父亲的电话，说姑爷（父亲姐姐的丈夫）出事了，出了车祸，在急救室里抢救，手机一下就掉在了地上，父亲再说什么已经听不太清了，慌忙的拿起手机挂断，赶忙打电话给嬢嬢（父亲的姐姐），没接，赶忙发消息给嬢嬢和堂哥（姑爷的儿子），没回，因为疫情的缘故，没法出门，就这样焦急等待了两个小时3分钟，堂哥回了句：已经走了。\n那样鲜活的生命，就这样因为一场意外而离开了这个世间。三告仍记得的，在那三个月前姑爷还专门叫他进去一起吃卤味，一起喝卡瓦斯，甚至姑爷还调侃着三告是个懒虫，在那个时光里，三告还在姑爷的水泥厂里面当着记录员，那里的环境是艰苦且充满烟尘的，混泥土在搅拌机里搅拌的时候，粉尘把世界染成了灰色一般，三告在操作室里还要去搅拌机前拿铁锹接住从搅拌机下落的混凝土，哗啦啦的一片，手握着铁锹，感觉就像下落的铁拳压在铁锹上一样，然后拿出来，看一下混泥土的成色，在之后调整水和水泥以及配料的比例。姑爷他是整个团队的领袖，在哪一个地方都有他的身影，大老板硬生生被他变成了小零工，从早到晚，一直忙碌着，不时检查一下机器，又不时去找需求方谈论价格。有单子时很忙，一车一车的打混凝土然后送去目的地，喝水的时间都不多，每一分都是辛苦钱，甚至有时候打到凌晨两三点，然后早上六七点就起来继续，虽然很累，但却很充实，也有闲暇的时候，比如说下雨天，在那个荒无人烟的高原上，没有绵绵细雨，只有倾盆大雨，每当下雨，三告总是偷偷跑去姑爷和嬢嬢住的房间里落得清闲，他们总是不在，要么是回家了没住在厂子里，要么就出门去见客户了。嬢嬢要闲一些，她会照看鸭子和种植一些菜苗，没装栅栏的时候鸭子总是跑过来把才冒出头的菜苗吃点，留下的一地脚印都是证据。\n一周只吃一次肉，其余基本都是配着蔬菜吃或者吃抓饭，幸好三告是不挑食的，姑爷和嬢嬢也会偷偷从家里带一些“加餐”，偷偷放在他们房子里，然后叫三告过去吃，都是些带肉的食物，都是一家人偏心些倒也正常。姑爷的性格在三告看来是很奇怪的，有时候十分和蔼可亲，有时候又十分苛刻不苟言笑，有时候又十分老不正经的。小时候的三告，是和嬢嬢和姑爷他们同住在一个院子里的，那个时候三告经常去姑爷家里玩，大堂哥的玩具总是很时髦，有时候玩的流连忘返，姑爷和嬢嬢就直接让三告留下来吃饭，那种留在血液里的感情，总归是让人深刻的。\n然而姑爷就这样离开了，二一年十二月四号参加的他的葬礼，堂姐喊三告不要看，说三告和姑爷同是一生肖，犯冲。就这样，三告盯着门，不知道想些什么，只是眼角有些泪花，像个面壁思过犯了错的孩子一样，下葬的车三告也不能坐，配着嬢嬢两个人在房子里盯着手机，一开始两个人都是沉默的，后来不知是不是风沙太大了，眼睛就有眼泪掉下来了，不知道是谁先掉眼泪的，都在安慰着对方说着别哭。\n在那一天，三告写下——现在才明白，相遇和离别真的就在一天，真的好多人和事还没来得及好好道别，就已不再重逢，不要回头，太过沉重，就把往西留在回忆里吧。白色的鸢尾，红色的灰烬，黄色的纸钱，雾灰的蓝天，远处有一点微光，只有风的声音，只余一声叹息。 12月4号，逝者已逝，愿安息。\n然后一起去吃席，三告在门口等着每一个曾在姑爷生命中住过一段时间的故人，记录着，饭菜上足之后，拿着酒杯，每一桌都鞠躬已表示感谢，烈酒下喉，前尘往事莫要再提。\n最后，三告写下这样一句话——每一个人的生命里，总有些时候会接触那些生离死别，就像那些冬天，你总是一个人踩着落在雪地上的枫叶然后落下脚印，毕竟那场雪，不是落在所有人身上的，你要明白，每一个人都在自己生命里，孤独的过冬。\n那夜 雪 来过 眼里都是白色 不止眼里 世界的尽头都是白色 就像曾经住在心底里的那个人 留下了一个白色的 充满孤寂的 背影 只是以后 雪 再来过 可那一望无际的白 被永远定格在了 那静默的时光里 于是 便不再瞧窗外看任何一眼了 ——未完待续\n","date":"2022-06-26T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/yujunshu-2/","title":"与君书（二）"},{"content":"video test 支持的 Shortcodes 详见: https://docs.stack.jimmycai.com/zh/writing/shortcodes\nHTML Code 1 \u0026lt;video src=\u0026#34;https://alist.leecq.cn/onedrive/1_1_48ed6325509e3d97c2b6eed7eabd821dc61c7518.mp4\u0026#34; controls \u0026gt;\u0026lt;/video\u0026gt; HTML video 测试1 Your browser does not support the video tag.\rHTML video 测试2 Shortcodes bilibili 测试 Shortcodes 腾讯视频 Shortcodes 本地视频 1 2 3 4 5 \u0026lt;!-- just video src --\u0026gt; Your browser doesn't support HTML5 video. Here is a link to the video instead. \u0026lt;!-- Other option --\u0026gt; Your browser doesn't support HTML5 video. Here is a link to the video instead. Your browser doesn't support HTML5 video. Here is a link to the video instead. ","date":"2021-07-31T00:33:55+08:00","image":"https://one.p.leecq.cn/E5Drive/imgs/1.jpg","permalink":"https://blog-g.leecq.cn/p/video-test/","title":"video-test"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode Vimeo Simple Shortcode ","date":"2021-07-30T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/%E8%87%AA%E5%AE%9A%E4%B9%89/","title":"自定义"},{"content":"Hugo 解析markdown时， 无法显示其中的HTML语句段 问题： hugo默认情况下无法正常显示markdown中内嵌的html，在生成的网页中，html代码会被\u0026lt;!-- raw HTML omitted --\u0026gt;替代。\n原因： 在2019年11月的hugo更新中，使用了Goldmark作为默认库，该库认为在md文档中嵌入HTML是不安全的行为；\n解决方法： 在Hogo的配置文件中添加如下代码段，以屏蔽其安全机制：\n1 2 3 4 [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true 或者是yaml:\n1 2 3 4 5 # 注意yaml的缩进可能不适用于你的文件 markup: goldmark: renderer: unsafe: true 来源： 作者：new房昭之 https://www.bilibili.com/read/cv4516916 出处：bilibili\n例子 code 向网页注入video标签 1 \u0026lt;video src=\u0026#34;https://alist.leecq.cn/d/onedrive/1_1_48ed6325509e3d97c2b6eed7eabd821dc61c7518.mp4\u0026#34; controls width=100% \u0026gt;你的浏览器不支持video标签,是时候换浏览器了\u0026lt;/video\u0026gt; 你的浏览器不支持video标签是时候换浏览器了\n","date":"2021-06-20T00:33:55+08:00","permalink":"https://blog-g.leecq.cn/p/hugo%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90md%E4%B8%ADhtml%E4%BB%A3%E7%A0%81/","title":"Hugo无法解析md中HTML代码"},{"content":" The world’s fastest framework for building websites. Hugo是最流行的开源静态站点生成器之一。凭借其惊人的速度和灵活性，Hugo使构建网站再次变得有趣。\n===\n安装 ​\tHugo是由Go语言开发的软件, 你可以在 GitHub 或者 镜像地址上获取到它的源码, 自行编译; 或者在 Releases · gohugoio/hugo · GitHub 获取到预编译版本 .\n​\t或者使用下面的指令一键安装\n1. Windows ```powershell\r# 1. 安装包管理工具 choco\rSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\r# 2. 安装 Hugo\rchoco install hugo -confirm\r# 如果你需要安转拓展的 Sass/SCSS 版本执行:\rchoco install hugo-extended -confirm\r```\r2. Mac OS ```shell\r# 1. 安装包管理工具 Brew\r/bin/bash -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026quot;\r# 2. 安装hugo\rbrew install hugo\r```\r3. Linux ```shell\r# Debian / Armbian / Ubuntu\rapt install hugo\r# CentOS\ryum install hugo\r```\r快速开始 ​\t快速的建立一个hugo构建的blog.\n1. **初始化: ** hugo new site \u0026lt;BlogName\u0026gt; 执行此步骤后会在工作目录中创建一个名为 BlogName的目录, 其中包含了站点的基本元素;\n```sh\r\u0026lt;BlogName\u0026gt;\r| config.toml # 项目配置文件\r+-+-archetypes # | \\-- default.md\r+---content # 内容, 创作的blog放在这个目录下\r+---data # +---layouts\r+---static # 静态文件\r\\---themes # 主题文件\r```\r2. 添加主题: \u0026gt; 推荐的主题: [Next](https://leecq.lanzoui.com/ijqbUpki8vc )\r你可以查看[themes.gohugo.io](themes.gohugo.io)上的主题列表。或者在社区中搜索你喜欢的主题样式.\r把主题下载下来后添加到项目的`themes`目录\r最后修改项目目录下的 `config.toml` 使其`theme=\u0026lt;你下载的主题名字\u0026gt;`\r3. **添加内容: ** hugo new posts/my-first-post.md\n\u0026gt; 注意: 他需要当前工作目录是你的项目目录, 否则会报错. 找不到config.toml\r执行此步骤会在`content/` 下创建 `posts/my-first-post.md` 文件作为一篇文章.\r使用`MarkDown`标记语法构建.\r4. 编辑和修改你的文章 如果你想编辑新创建的内容文件，它会像这样开始:\r1 2 3 4 5 6 7 --- title: \u0026#34;My First Post\u0026#34; date: 20121-05-29T08:47:11+08:00 draft: true --- # 草稿不会被部署;一旦你完成了一篇文章，更新文章标题，写上draft: false 5. **启动Hugo服务器 ** `hugo server -D`\r现在，启动Hugo服务器并启用草稿:\r新网站一般会被部署在 `http://localhost:1313/`。\r6. 自定义主题 打开并编辑`config.toml`文件.\r1 2 3 4 baseURL = \u0026#34;https://example.org/\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;My New Hugo Site\u0026#34; theme = \u0026#34;ananke\u0026#34; 用一自己的东西替换上面的标题。\r另外，如果您已经准备好了一个域名，那么设置baseURL。注意，运行本地开发服务器时不需要这个值。\r\u0026gt; 提示:\r\u0026gt;\r\u0026gt; ​\t当Hugo服务器运行时，对站点配置或站点中的任何其他文件进行更改，您将立即在浏览器中看到更改，但您可能需要清空缓存。\r*有关特定于主题的配置选项，请参阅[主题站点](https://github.com/theNewDynamic/gohugo-theme-ananke)。*\r7. 构建静态页面 hugo -D 默认情况下输出将在`./public/ `目录下.\r你可以使用 `-d / --destination `标记来显示的指定输出位置.\r","date":"2021-05-29T00:33:55+08:00","image":"https://blog-g.leecq.cn/img/hugo-hone-page.png","permalink":"https://blog-g.leecq.cn/p/hugo-%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/","title":"Hugo 快速开始"},{"content":"终于有了一个属于自己的网站 网站建立的过程 1、域名申请 在阿里云(aliyun.com)申请了自己的域名(leech.xyz)一年，花了6元RMB。\n2、空间（云主机）的申请 在强人网络（https://www.qiangren.net/）购买了免费的云空间，主机位于加拿大，延迟一般。\n4、平台上传 将准备好的wordpress平台上传到空间。并解压到/根目录\n5、Wordpress初始化 配置数据库（参数在空间提供商给的邮件中）。\n6、调试 修改主题、配置用户等。\n感谢：苍水酱告诉我免费的空间提供商。\n腾讯课堂：周红川老师的30min学会网站搭建课程\n","date":"2019-08-25T21:00:57+08:00","permalink":"https://blog-g.leecq.cn/p/%E7%BB%88%E4%BA%8E%E6%9C%89%E4%BA%86%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99/","title":"终于有了一个属于自己的网站"},{"content":"蓝色大门-演讲稿 v1.1 开场 《蓝色大门》这部电影中，我印象最深刻的有两句话。\n一句，是：我看不到、我看不到、我看不到啦。它在影片的最开头，说着这话的时候都还没有画面，我就开始疑惑，他看不见的到底是什么？能记住这样一句话一是她很简单，二是它真的重复了很多很多遍，就像我们记abandon一样，又怎么会记不住呢？\n第二句是：“虽然我闭着眼睛也看不见自己，但是却可以看见你。”这句话很美。想想如果在未来的某一天能把这样一句话写给自己的女朋友是多么美妙的一件事情，对吧？ 自然就记得牢靠了。这句话把对未来的那一种憧憬，向往，迷恋和深深的对你的爱都表现的淋漓尽致。\n整个影片也就是在描绘着一个，我看不见，到，我看能看见你，的这么一个过程。看过这部电影的人呢？都应该知道这两句话出自同一个人之口，一在片头一在片尾，很难想象一个人对未来的态度会有如此大的改变，这种改变又是因何而起呢。——那都是因为爱情，在爱的过程中，他们都遇见了好的对方，也遇见了更好的自己。\n关于爱情——孟克柔 在影片中，虽然孟克柔对张世豪说自己是同性恋，但是在电影中。他一直在墙上写下：“我是女生，我喜欢男生。”以及在影片的末尾，她所说的那句话“虽然我闭着眼睛也看不见自己，但是却可以看见你。”还有最后。那甜美的发自内心的笑容，唯一的不表达了他已经爱上了一名男生，她已经不再是同性恋，爱已经改变了他的爱情观，同时也改变了她对人生的态度；知道这意味着什么吗？爱情有时候是可以毁掉你的三观的！当然了，在毁掉的同时也会在建立起一个更好的三观。让自己更快乐，更幸福，更自在，更了解自己的心。\n如果我们仔细观察孟克柔的嘴角，你会发现电影的前半段几乎看不到她的笑容，一直板着脸，只有偶尔与林月珍相处时才会有那么一点点的略微为难的笑容。为什么？不笑，不就是意味着。她不快乐，不幸福吗？因为没有人能够理解她，她也没有一个能够倾诉的对象，最好的朋友是林月珍，但不能对他说我爱你。也没有人爱着她。只能一个人独自承受那一份孤寂压抑。也许。还有那一种连他自己都没有察觉到的对男生的一点点好感，却是无根之萍，在慌乱与恐惧中被藏的严严实实。直到张士豪对她锲而不舍的爱才慢慢融化了她心中的坚冰。直到她抗拒体育老师找她时，她主动拉起了张士豪的手、十指相扣的时候，她的心才出现了点点空隙。\n而到了影片的后期，你会看到：她一直与笑容同行。尤其是在最后骑单车的时候，脑袋轻轻抬起，嘴角微微上扬，露出了阳光、开朗又自在的自信的笑，这都是因为她爱上了一个阳光开朗又自在的男孩儿——张士豪。因为她心中有那一份真正的爱变得多么快乐，幸福，自在。爱情观的改变使她自己终于敢直面这个广阔的世界。也只有在那时她才可以说出，“虽然我闭着眼睛也看不见自己，但是却可以看见你。”这样一句美妙的话。\n从另一种角度看，有没有可能孟克柔并不是真正的同性恋呢？\n同性恋·【范莹莹】 那有没有可能她并不是不喜欢男生？啊？而是出于某些原因的排斥呢？对林月珍的爱。会不会仅仅是一种对朋友的依恋呢？有可能吧。\n大家都知道，孟克柔，生长在一个单亲家庭。他的父亲离开了，至于为何离开是生是死、是离异、还是其他的种种原因，影片中没有讲，我们也都不知道，但这不重要。重要的是。他去问了他妈妈这样一句话：“爸离开的时候，你是怎么活过来的？”这句话说明了，这个男人的离开对她和她的妈妈的生活都产生了巨大的影响——大到要“活过来”这三个字才能表达出当时的那种痛苦中走出的过程。这句话瞬间给人一种，哀莫大于心死的感觉。看到这里，我们应该明白了。孟克柔不喜欢男生的根本原因，可能是在于她和她母亲曾经被男人伤过。她害怕，她父亲离开的阴影在她的脑中始终无法抹去。这是她对接近她的男生的一种排斥根本原因。直到张士豪对她锲而不舍的爱才慢慢融化了她心中的坚冰。\n所以之前她怕爱上男生，于是女生是她唯一的选择，那时她开始给自己贴上标签，于是就真的以为自己喜欢女生有了这样一个错误的爱情观。这样一个错误的爱情观，让她只敢活在自己想象中的狭窄世界之中，而不敢活在现实的广阔世界中。这样的人生观让她的生活变得狭窄，变得压抑，变得不幸福，顾少见笑容。所以当她说看不见的时候。有可能是她不敢看见。或者说她不敢把自己看见的内容说出来，她一直在逃避。\n而到了影片的后期，她一直与笑容同行。尤其是在最后骑单车的时候，脑袋轻轻抬起，嘴角微微上扬，露出了阳光、开朗又自在的自信的笑，这都是因为她爱上了一个阳光开朗又自在的男孩儿——张世豪。因为她心中有那一份真正的爱变得多么快乐，幸福，自在。爱情观的改变使她自己终于敢直面这个广阔的世界。也只有在那时她才可以说出，“虽然我闭着眼睛也看不见自己，但是却可以看见你。”这样一句美妙的话。\n刚才呢，我一直在思考一个问题，假如孟克柔对林月珍和张士豪都是真爱，之前她爱着林月珍，之后她爱上了张士豪，前一个是女生、后一个是男生，那么能否证明，真爱与性别无关这一论点呢？当然这不重要，重要的是爱对孟克柔的改变是有益的。\n同样的林月珍、张士豪因为爱，也或多或少有一定的改变，但不太明显，我们就不在多说。\n电影中表现的爱情固然非常美好，但是在其他方面也夹杂这一点点的不纯洁，比如说朋友间的欺骗、和一段三角的爱恋。下面我们请丁浩楠同学讲一下他对电影中的三角恋的看法。\n三角恋·【丁浩楠】 关于成长 刚才我们谈论了那么多的爱情，但是如果我们就借此说这仅仅是一部讲述“青春萌动，幻想爱情”的电影；如果我们就认为“看不见自己，却可以看见你”只是一句对爱情的呢喃的话？那么你就大错特错了。前面我们也曾提到这部电影是在讲最初的“我看不见”到“我看见你”的过程。\n那么我看不见代表着什么？代表着对人生未来的困惑，迷茫。\n我看见你又是一种什么样的过程和状态呢？想一想。你在睁开眼睛的时候，什么情况下能看见自己又在什么情况下看不见自己？是不是你低头驻足时能看见你自己又在。抬头走路的时候看不见你自己，那么同样的，当我们闭着眼睛也看不见自己的时候，说明了什么？说明了我们的心不再低头，我们的心仰望天空，我的心以你为标榜，共同走向我们期待的南山蓝色的大门。所以这也是一部讲述人生的困惑和走向成熟的电影。\n孟克柔再说看不见的时候，迷茫着什么？林月珍在想去的表白的时候犹豫着什么。张世豪想要在那个夏天留下的又是什么？\n所以你会看见，孟克柔，会在半夜里跑到她妈的房间里问：“爸离开的时候，你是怎么活过来的。”她会认为在接受了一个男人的吻之后，就会爱上男生儿去问体育老师和张世豪，“你会吻我吗？”但当体育老师找来的时候，她又开始惧怕。也就在那时，她第一次主动的拉起了张世豪的手，十指相扣。这是孟克柔的迷茫和践行。\n同样的，林月珍和张士豪都有他们各自的迷茫和对应的践行，且听张春月和王宇纯同学为我们一一道来。\n关于成长——林月珍·【张春月】 关于成长——张世豪·【王宇纯】 所以你会看到林月珍会因为爱去收集张世豪丢掉的东西。会说出如果我用她的原子笔写她的名字写道，莫干，是不是她就会爱上我？她会在被拒绝，被说出“对不起”之后，一个人含着泪到天台上，又丢掉，烧掉那些曾经无比在意的东西，然后突然舍不得，再捡回来。在好朋友面前，她还故作坚强地幻想着她与张世豪不可能的美好未来。可是。最终。她还是不得不在本子上变了名字，开始哭着写上了木村拓哉。\n所以张世豪会一遍一遍的对孟克柔说，我叫张士豪型，游泳队吉他社，长得还不错。会每天晚上到她家的店里吃水饺，走的时候还会说一声一句我吃饱回家喽！会对自己喜欢的人说出自己的秘密。孟克柔带林月珍去见他之后，他会一遍又一遍的追问孟克柔，你是什么意思？在最后他会对她说：“如果有一天，或许一年，或许三年，如果你开始喜欢男生，你一定要第一个告诉我哦。”（笑屁啊！）\n这些都是他们对爱的试探，对青春的践行也是对成熟之路的迷茫。只有经过了这些试探，践行我们才可以看得清自己，才能看得见你\n也许只有这样，我们才能在三年，五年，甚至更久之后，回首时看见那一扇蓝色的大门和门前的你。\n结语\u0026amp;蓝色的大门 电影的名字叫做《蓝色大门》。但是在电影中你看不到任何一扇门是蓝色的。也许你会疑惑会去寻找，直到你听到最后那一段独白的时候，“我在想一年，三年，五年之后，我们会变成什么样子呢？由于你善良，开朗又自在，你应该更帅吧！于是我似乎看到。很多年。以后。你站在一扇蓝色的大门前。下午三点的阳光，一两颗青春痘。你笑着，我跑向你问你好不好，你点点头。三年五年以后，甚至更久、更久以后我们会变成什么样的大人呢？是体育老师还是我妈？虽然我闭着眼睛也看不见自己，但是却可以看见你。”你才会发现，整部电影就应该在一扇蓝色的大门之内。你站在门口看着其中的点点滴滴，所以忘记了它的本身。蓝色在艺术中代表着永恒青春在我们心中永存，所以。《蓝色大门》就是我们青春永恒的大门。当然，也有人说这是蓝色的大门，只是台北师大附中的一扇大门。我认为这不重要，那也只是青春的一个缩影而已。\n在最后。这电影还给我们带来了很多回忆。因为此时的我们相比，他们三年五年都已经快过去了。我们就要成为他们口中的大人了。在看到最后那一个爱妹儿的时候。我们都能深刻的感觉到青春我来过。就在这时，你的心中。就会发现那一单属于你自己的蓝色的大门，永恒气力。此时。我们在自己的蓝色大门中看到了什么？我们就已经成为了什么样子的大人。\n","date":"2018-12-11T00:00:00Z","image":"https://blog-g.leecq.cn/cover_%E8%93%9D%E8%89%B2%E5%A4%A7%E9%97%A8.jpg","permalink":"https://blog-g.leecq.cn/p/%E8%A7%82%E5%90%8E%E6%84%9F-%E8%93%9D%E8%89%B2%E5%A4%A7%E9%97%A8/","title":"观后感 - 蓝色大门"},{"content":"目标 编写一个简洁的Loki配置文件，要求：\n单一部署，(=target=all) 使用本次磁盘作为存储(数据根目录：/opt/app/loki/data) 监听在端口3100上 使用简单的用户名密码认证(由Nginx实现，Loki不包含认证服务) 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # loki-config.yaml auth_enabled: false server: http_listen_port: 3100 common: path_prefix: /opt/app/loki/data storage: filesystem: chunks_directory: /opt/app/loki/data/chunks rules_directory: /opt/app/loki/data/rules replication_factor: 1 ring: instance_addr: localhost kvstore: store: inmemory query_scheduler: # the TSDB index dispatches many more, but each individually smaller, requests. # We increase the pending request queue sizes to compensate. max_outstanding_requests_per_tenant: 32768 schema_config: configs: - from: 2000-07-01 store: tsdb object_store: filesystem schema: v13 index: prefix: index_ period: 24h storage_config: filesystem: directory: /opt/app/loki/data 启动命令 单节点启动：nohup loki-linux-amd64 -target=all -config.file=loki-config.yaml\n","date":"0001-01-01T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/","title":""},{"content":"https://github.com/greenbone https://hub.docker.com/r/virsacer/gvm\n","date":"0001-01-01T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/","title":""},{"content":"","date":"0001-01-01T00:00:00Z","permalink":"https://blog-g.leecq.cn/p/","title":""}]