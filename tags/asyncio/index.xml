<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Asyncio on LeeCQ小空间</title><link>https://blog-g.leecq.cn/tags/asyncio/</link><description>Recent content in Asyncio on LeeCQ小空间</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 13 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog-g.leecq.cn/tags/asyncio/index.xml" rel="self" type="application/rss+xml"/><item><title>Async 协程入门</title><link>https://blog-g.leecq.cn/p/async-%E5%8D%8F%E7%A8%8B%E5%85%A5%E9%97%A8/</link><pubDate>Mon, 13 Feb 2023 00:00:00 +0000</pubDate><guid>https://blog-g.leecq.cn/p/async-%E5%8D%8F%E7%A8%8B%E5%85%A5%E9%97%A8/</guid><description>&lt;h2 id="async-库和python相关关键字"&gt;Async 库和Python相关关键字
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt; - 关键字 - 定义一个 Async函数或方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt; - 关键字 - 挂起 coroutine 的执行以等待一个 awaitable 对象。 只能在 coroutine function 内部使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;await&lt;/code&gt; 会创建一个task，将Task放入事件循环，释放操作句柄交给调度器，阻塞上下文知道await的Task返回结果&lt;/p&gt;&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-python" data-lang="python"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;asyncio&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;async&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;func&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;await&lt;/span&gt; &lt;span class="n"&gt;asyncio&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start="3"&gt;
&lt;li&gt;coroutine - 定义 - 协程&lt;/li&gt;
&lt;li&gt;coroutine function - 定义 - 由 &lt;code&gt;async def &lt;/code&gt; 定义的函数；&lt;/li&gt;
&lt;li&gt;conoutine object - 定义 - coroutine function的一个实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;值得注意的是，当我们直接调用了一个 coroutine function 的时候，并不会调用该函数的具体内容，而是会生成一个 coroutine object，这个obj只有在asyncio 的 event_loop 中被调度。这个过程类似于我们生成器和生成器函数。&lt;/p&gt;&lt;/blockquote&gt;
&lt;ol start="5"&gt;
&lt;li&gt;awaitable对象 - 定义 - 可以被await语句中使用的对象，可以是coroutine function, 或实现了 &lt;code&gt;__await__&lt;/code&gt; 魔术方法的对象。&lt;/li&gt;
&lt;li&gt;asyncio.run() - 函数 - 协程事件循环的入口。&lt;/li&gt;
&lt;li&gt;asyncio.create_task() - 函数创建一个conoutine object包装为Task并加入到事件循环。&lt;/li&gt;
&lt;li&gt;asyncio.gather(*coros_or_futures, return_exceptions=False) - 函数 - 返回给定协程futures 的未来聚合结果。&lt;br&gt;
协程将被包装在 future 中并在事件循环中进行调度。它们不一定按照传入的顺序进行安排。&lt;br&gt;
所有 future 必须共享相同的事件循环。如果所有任务都成功完成，则返回的 future 的结果是结果列表（按照原始序列的顺序，不一定是结果到达的顺序）。如果return_exceptions为True，则任务中的异常将被视为与成功结果相同，并收集在结果列表中；否则，第一个引发的异常将立即传播到返回的 future。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="相关视频"&gt;相关视频：
&lt;/h2&gt;
&lt;div class="video-wrapper"&gt;
&lt;iframe src="https://player.bilibili.com/player.html?as_wide=1&amp;amp;high_quality=1&amp;amp;page=1&amp;bvid=BV1oa411b7c9"
scrolling="no"
frameborder="no"
framespacing="0"
allowfullscreen="true"
&gt;
&lt;/iframe&gt;
&lt;/div&gt;</description></item></channel></rss>